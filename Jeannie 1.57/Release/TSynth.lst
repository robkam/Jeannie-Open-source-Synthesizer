
C:\Users\rolfd\AppData\Local\Temp\VMBuilds\TSynth\teensy41\Release/TSynth.ino.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001400:	4b79      	ldr	r3, [pc, #484]	; (600015e8 <ResetHandler+0x1e8>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001402:	f44f 012a 	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001406:	4a79      	ldr	r2, [pc, #484]	; (600015ec <ResetHandler+0x1ec>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001408:	4879      	ldr	r0, [pc, #484]	; (600015f0 <ResetHandler+0x1f0>)
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
void startup_late_hook(void)		__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
6000140a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000140e:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
60001410:	6418      	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001412:	4a78      	ldr	r2, [pc, #480]	; (600015f4 <ResetHandler+0x1f4>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001414:	6399      	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001416:	4695      	mov	sp, r2
	__asm__ volatile("dsb":::"memory");
60001418:	f3bf 8f4f 	dsb	sy
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000141c:	4a76      	ldr	r2, [pc, #472]	; (600015f8 <ResetHandler+0x1f8>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000141e:	f503 3330 	add.w	r3, r3, #180224	; 0x2c000
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001422:	4976      	ldr	r1, [pc, #472]	; (600015fc <ResetHandler+0x1fc>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001424:	2008      	movs	r0, #8
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001426:	428a      	cmp	r2, r1
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
	__asm__ volatile("dsb":::"memory");
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001428:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000142c:	d00f      	beq.n	6000144e <ResetHandler+0x4e>
	while (dest < dest_end) {
6000142e:	4b74      	ldr	r3, [pc, #464]	; (60001600 <ResetHandler+0x200>)
60001430:	429a      	cmp	r2, r3
60001432:	d20c      	bcs.n	6000144e <ResetHandler+0x4e>
60001434:	43d4      	mvns	r4, r2
60001436:	4608      	mov	r0, r1
60001438:	4423      	add	r3, r4
6000143a:	f023 0303 	bic.w	r3, r3, #3
6000143e:	3304      	adds	r3, #4
60001440:	440b      	add	r3, r1
		*dest++ = *src++;
60001442:	f850 1b04 	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001446:	4298      	cmp	r0, r3
		*dest++ = *src++;
60001448:	f842 1b04 	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000144c:	d1f9      	bne.n	60001442 <ResetHandler+0x42>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000144e:	4a6d      	ldr	r2, [pc, #436]	; (60001604 <ResetHandler+0x204>)
60001450:	496d      	ldr	r1, [pc, #436]	; (60001608 <ResetHandler+0x208>)
60001452:	428a      	cmp	r2, r1
60001454:	d00f      	beq.n	60001476 <ResetHandler+0x76>
	while (dest < dest_end) {
60001456:	4b6d      	ldr	r3, [pc, #436]	; (6000160c <ResetHandler+0x20c>)
60001458:	429a      	cmp	r2, r3
6000145a:	d20c      	bcs.n	60001476 <ResetHandler+0x76>
6000145c:	43d4      	mvns	r4, r2
6000145e:	4608      	mov	r0, r1
60001460:	4423      	add	r3, r4
60001462:	f023 0303 	bic.w	r3, r3, #3
60001466:	3304      	adds	r3, #4
60001468:	440b      	add	r3, r1
		*dest++ = *src++;
6000146a:	f850 1b04 	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000146e:	4283      	cmp	r3, r0
		*dest++ = *src++;
60001470:	f842 1b04 	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001474:	d1f9      	bne.n	6000146a <ResetHandler+0x6a>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001476:	4a66      	ldr	r2, [pc, #408]	; (60001610 <ResetHandler+0x210>)
60001478:	4b66      	ldr	r3, [pc, #408]	; (60001614 <ResetHandler+0x214>)
6000147a:	429a      	cmp	r2, r3
6000147c:	d20b      	bcs.n	60001496 <ResetHandler+0x96>
6000147e:	43d0      	mvns	r0, r2
60001480:	4611      	mov	r1, r2
		*dest++ = 0;
60001482:	2400      	movs	r4, #0
60001484:	4403      	add	r3, r0
60001486:	f023 0303 	bic.w	r3, r3, #3
6000148a:	3304      	adds	r3, #4
6000148c:	4413      	add	r3, r2
6000148e:	f841 4b04 	str.w	r4, [r1], #4
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001492:	428b      	cmp	r3, r1
60001494:	d1fb      	bne.n	6000148e <ResetHandler+0x8e>
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001496:	4a60      	ldr	r2, [pc, #384]	; (60001618 <ResetHandler+0x218>)
60001498:	f44f 0170 	mov.w	r1, #15728640	; 0xf00000

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000149c:	2300      	movs	r3, #0
6000149e:	4c5f      	ldr	r4, [pc, #380]	; (6000161c <ResetHandler+0x21c>)
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
600014a0:	6011      	str	r1, [r2, #0]
600014a2:	4a5f      	ldr	r2, [pc, #380]	; (60001620 <ResetHandler+0x220>)

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
600014a4:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
600014a8:	3301      	adds	r3, #1
600014aa:	2bb0      	cmp	r3, #176	; 0xb0
600014ac:	d1fa      	bne.n	600014a4 <ResetHandler+0xa4>
600014ae:	4b5d      	ldr	r3, [pc, #372]	; (60001624 <ResetHandler+0x224>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600014b0:	2180      	movs	r1, #128	; 0x80
600014b2:	4a5d      	ldr	r2, [pc, #372]	; (60001628 <ResetHandler+0x228>)
600014b4:	f803 1b01 	strb.w	r1, [r3], #1
600014b8:	4293      	cmp	r3, r2
600014ba:	d1fb      	bne.n	600014b4 <ResetHandler+0xb4>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014bc:	4d5b      	ldr	r5, [pc, #364]	; (6000162c <ResetHandler+0x22c>)
600014be:	f04f 3880 	mov.w	r8, #2155905152	; 0x80808080
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014c2:	495b      	ldr	r1, [pc, #364]	; (60001630 <ResetHandler+0x230>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014c4:	f04f 32ff 	mov.w	r2, #4294967295
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014c8:	4b5a      	ldr	r3, [pc, #360]	; (60001634 <ResetHandler+0x234>)
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600014ca:	2600      	movs	r6, #0

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014cc:	f8df a1a0 	ldr.w	sl, [pc, #416]	; 60001670 <ResetHandler+0x270>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014d0:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 60001674 <ResetHandler+0x274>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600014d4:	601c      	str	r4, [r3, #0]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014d6:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014da:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014de:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014e2:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014e6:	680b      	ldr	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014e8:	4f53      	ldr	r7, [pc, #332]	; (60001638 <ResetHandler+0x238>)
	SCB_VTOR = (uint32_t)_VectorsRam;

	reset_PFD();

	// enable exception handling
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014ea:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014ee:	600b      	str	r3, [r1, #0]

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014f0:	69fb      	ldr	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014f2:	493d      	ldr	r1, [pc, #244]	; (600015e8 <ResetHandler+0x1e8>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;

	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014f4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014f8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014fc:	61fb      	str	r3, [r7, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
60001500:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
60001504:	f043 0340 	orr.w	r3, r3, #64	; 0x40
60001508:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000150a:	668a      	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
6000150c:	66ca      	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
6000150e:	670a      	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
60001510:	674a      	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
60001512:	f024 fd87 	bl	60026024 <configure_cache>
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
60001516:	4a49      	ldr	r2, [pc, #292]	; (6000163c <ResetHandler+0x23c>)
	_VectorsRam[15] = systick_isr;
60001518:	4b49      	ldr	r3, [pc, #292]	; (60001640 <ResetHandler+0x240>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
6000151a:	2063      	movs	r0, #99	; 0x63
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
6000151c:	63a2      	str	r2, [r4, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000151e:	2103      	movs	r1, #3

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
60001520:	63e3      	str	r3, [r4, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001522:	4a48      	ldr	r2, [pc, #288]	; (60001644 <ResetHandler+0x244>)
	SYST_CVR = 0;
60001524:	4b48      	ldr	r3, [pc, #288]	; (60001648 <ResetHandler+0x248>)
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001526:	6010      	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001528:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
6000152c:	601e      	str	r6, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000152e:	f842 1c04 	str.w	r1, [r2, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001532:	f600 70a1 	addw	r0, r0, #4001	; 0xfa1
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001536:	4945      	ldr	r1, [pc, #276]	; (6000164c <ResetHandler+0x24c>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001538:	4a45      	ldr	r2, [pc, #276]	; (60001650 <ResetHandler+0x250>)
6000153a:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000153e:	680b      	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001540:	4a44      	ldr	r2, [pc, #272]	; (60001654 <ResetHandler+0x254>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001542:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001546:	600b      	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
60001548:	6813      	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000154a:	4943      	ldr	r1, [pc, #268]	; (60001658 <ResetHandler+0x258>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000154c:	f043 0301 	orr.w	r3, r3, #1
60001550:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001552:	6803      	ldr	r3, [r0, #0]
60001554:	600b      	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001556:	f024 ffb5 	bl	600264c4 <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
6000155a:	f8c5 8104 	str.w	r8, [r5, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
6000155e:	483f      	ldr	r0, [pc, #252]	; (6000165c <ResetHandler+0x25c>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001560:	f8c5 a100 	str.w	sl, [r5, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001564:	f8c5 80f4 	str.w	r8, [r5, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001568:	f8c5 90f0 	str.w	r9, [r5, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
6000156c:	f025 fafc 	bl	60026b68 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001570:	6ef9      	ldr	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
60001572:	4a3b      	ldr	r2, [pc, #236]	; (60001660 <ResetHandler+0x260>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001574:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001578:	4b3a      	ldr	r3, [pc, #232]	; (60001664 <ResetHandler+0x264>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000157a:	66f9      	str	r1, [r7, #108]	; 0x6c
	PIT_MCR = 0;
6000157c:	6016      	str	r6, [r2, #0]
	PIT_TCTRL0 = 0;
6000157e:	f8c2 6108 	str.w	r6, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
60001582:	f8c2 6118 	str.w	r6, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001586:	f8c2 6128 	str.w	r6, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
6000158a:	f8c2 6138 	str.w	r6, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000158e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
60001590:	07d2      	lsls	r2, r2, #31
60001592:	d408      	bmi.n	600015a6 <ResetHandler+0x1a6>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001594:	f642 6215 	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001598:	4933      	ldr	r1, [pc, #204]	; (60001668 <ResetHandler+0x268>)
6000159a:	6559      	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000159c:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
6000159e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
600015a0:	f042 0201 	orr.w	r2, r2, #1
600015a4:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600015a6:	4a2f      	ldr	r2, [pc, #188]	; (60001664 <ResetHandler+0x264>)
600015a8:	4c30      	ldr	r4, [pc, #192]	; (6000166c <ResetHandler+0x26c>)
600015aa:	6893      	ldr	r3, [r2, #8]
600015ac:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
600015b0:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
600015b2:	f024 fda9 	bl	60026108 <configure_external_ram>
#endif
	startup_early_hook();
600015b6:	f025 faab 	bl	60026b10 <__startup_early_hook_veneer>
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
600015ba:	6823      	ldr	r3, [r4, #0]
	while (millis() < 20) ; // wait at least 20ms before starting USB
600015bc:	2b13      	cmp	r3, #19
600015be:	d9fc      	bls.n	600015ba <ResetHandler+0x1ba>
	usb_init();
600015c0:	f025 f840 	bl	60026644 <usb_init>
	analog_init();
600015c4:	f025 f8ea 	bl	6002679c <analog_init>
	pwm_init();
600015c8:	f025 f96a 	bl	600268a0 <__pwm_init_veneer>
	tempmon_init();
600015cc:	f024 ffac 	bl	60026528 <tempmon_init>

	startup_late_hook();
600015d0:	f025 fa2a 	bl	60026a28 <__startup_late_hook_veneer>
600015d4:	6823      	ldr	r3, [r4, #0]
	while (millis() < 300) ; // wait at least 300ms before calling user code
600015d6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015da:	d3fb      	bcc.n	600015d4 <ResetHandler+0x1d4>
	//printf("before C++ constructors\n");
	__libc_init_array();
600015dc:	f025 f9cc 	bl	60026978 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
600015e0:	f025 faf6 	bl	60026bd0 <__main_veneer>
	
	while (1) asm("WFI");
600015e4:	bf30      	wfi
600015e6:	e7fd      	b.n	600015e4 <ResetHandler+0x1e4>
600015e8:	400ac000 	.word	0x400ac000
600015ec:	aaaaabff 	.word	0xaaaaabff
600015f0:	00200007 	.word	0x00200007
600015f4:	20058000 	.word	0x20058000
600015f8:	00000000 	.word	0x00000000
600015fc:	600ab500 	.word	0x600ab500
60001600:	00027988 	.word	0x00027988
60001604:	20000000 	.word	0x20000000
60001608:	600d2e8c 	.word	0x600d2e8c
6000160c:	20005c20 	.word	0x20005c20
60001610:	20005c20 	.word	0x20005c20
60001614:	20016300 	.word	0x20016300
60001618:	e000ed88 	.word	0xe000ed88
6000161c:	20015c00 	.word	0x20015c00
60001620:	0001cdd1 	.word	0x0001cdd1
60001624:	e000e400 	.word	0xe000e400
60001628:	e000e4a0 	.word	0xe000e4a0
6000162c:	400d8000 	.word	0x400d8000
60001630:	e000ed24 	.word	0xe000ed24
60001634:	e000ed08 	.word	0xe000ed08
60001638:	400fc000 	.word	0x400fc000
6000163c:	0001e9d1 	.word	0x0001e9d1
60001640:	0001ea15 	.word	0x0001ea15
60001644:	e000e014 	.word	0xe000e014
60001648:	e000e018 	.word	0xe000e018
6000164c:	e000edfc 	.word	0xe000edfc
60001650:	20200000 	.word	0x20200000
60001654:	e0001000 	.word	0xe0001000
60001658:	20015644 	.word	0x20015644
6000165c:	30a32c00 	.word	0x30a32c00
60001660:	40084000 	.word	0x40084000
60001664:	400d4000 	.word	0x400d4000
60001668:	56c00000 	.word	0x56c00000
6000166c:	2001564c 	.word	0x2001564c
60001670:	2018101b 	.word	0x2018101b
60001674:	13110d0c 	.word	0x13110d0c

60001678 <compare(void const*, void const*)>:
    data[i++] = String(str);
  }
}

FLASHMEM int compare(const void *a, const void *b) {
  return ((PatchNoAndName*)a)->patchNo - ((PatchNoAndName*)b)->patchNo;
60001678:	6800      	ldr	r0, [r0, #0]
6000167a:	680b      	ldr	r3, [r1, #0]
}
6000167c:	1ac0      	subs	r0, r0, r3
6000167e:	4770      	bx	lr

60001680 <myPitchBend(unsigned char, int)>:
				tft.setCursor(56,21);
				tft.setTextColor(ST7735_WHITE);
				tft.print(oscWaveformB);
				draw_Waveform(oscWaveformB, ST7735_ORANGE);
				printPWMrate();
				ParUpdate = true;
60001680:	ee07 1a90 	vmov	s15, r1
60001684:	4a1d      	ldr	r2, [pc, #116]	; (600016fc <myPitchBend(unsigned char, int)+0x7c>)
			}
60001686:	4b1e      	ldr	r3, [pc, #120]	; (60001700 <myPitchBend(unsigned char, int)+0x80>)
{
public:
	AudioSynthWaveformDc() : AudioStream(0, NULL), state(0), magnitude(0) {}
	// immediately jump to the new DC level
	void amplitude(float n) {
		if (n > 1.0f) n = 1.0f;
60001688:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
				tft.setCursor(56,21);
				tft.setTextColor(ST7735_WHITE);
				tft.print(oscWaveformB);
				draw_Waveform(oscWaveformB, ST7735_ORANGE);
				printPWMrate();
				ParUpdate = true;
6000168c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
60001690:	ed92 7a00 	vldr	s14, [r2]
			}
60001694:	ed93 6a00 	vldr	s12, [r3]
60001698:	eddf 7a1a 	vldr	s15, [pc, #104]	; 60001704 <myPitchBend(unsigned char, int)+0x84>
				tft.setCursor(56,21);
				tft.setTextColor(ST7735_WHITE);
				tft.print(oscWaveformB);
				draw_Waveform(oscWaveformB, ST7735_ORANGE);
				printPWMrate();
				ParUpdate = true;
6000169c:	ee66 6a87 	vmul.f32	s13, s13, s14
			}
600016a0:	ed9f 5a19 	vldr	s10, [pc, #100]	; 60001708 <myPitchBend(unsigned char, int)+0x88>
600016a4:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
600016a8:	eebd 7ae6 	vcvt.s32.f32	s14, s13
600016ac:	eeba 7aef 	vcvt.f32.s32	s14, s14, #1
600016b0:	ee27 7a06 	vmul.f32	s14, s14, s12
600016b4:	ee67 7a27 	vmul.f32	s15, s14, s15
600016b8:	ee67 7a85 	vmul.f32	s15, s15, s10
600016bc:	eef4 7ae5 	vcmpe.f32	s15, s11
600016c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600016c4:	dd07      	ble.n	600016d6 <myPitchBend(unsigned char, int)+0x56>
600016c6:	4b11      	ldr	r3, [pc, #68]	; (6000170c <myPitchBend(unsigned char, int)+0x8c>)
		else if (n < -1.0f) n = -1.0f;
		int32_t m = (int32_t)(n * 2147418112.0f);
		__disable_irq();
600016c8:	b672      	cpsid	i
		magnitude = m;
600016ca:	4a11      	ldr	r2, [pc, #68]	; (60001710 <myPitchBend(unsigned char, int)+0x90>)
		state = 0;
600016cc:	2100      	movs	r1, #0
	void amplitude(float n) {
		if (n > 1.0f) n = 1.0f;
		else if (n < -1.0f) n = -1.0f;
		int32_t m = (int32_t)(n * 2147418112.0f);
		__disable_irq();
		magnitude = m;
600016ce:	61d3      	str	r3, [r2, #28]
		state = 0;
600016d0:	7611      	strb	r1, [r2, #24]
		__enable_irq();
600016d2:	b662      	cpsie	i
600016d4:	4770      	bx	lr
public:
	AudioSynthWaveformDc() : AudioStream(0, NULL), state(0), magnitude(0) {}
	// immediately jump to the new DC level
	void amplitude(float n) {
		if (n > 1.0f) n = 1.0f;
		else if (n < -1.0f) n = -1.0f;
600016d6:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
600016da:	eef4 7ac7 	vcmpe.f32	s15, s14
600016de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600016e2:	d408      	bmi.n	600016f6 <myPitchBend(unsigned char, int)+0x76>
600016e4:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 60001714 <myPitchBend(unsigned char, int)+0x94>
600016e8:	ee67 7a87 	vmul.f32	s15, s15, s14
600016ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
600016f0:	ee17 3a90 	vmov	r3, s15
600016f4:	e7e8      	b.n	600016c8 <myPitchBend(unsigned char, int)+0x48>
600016f6:	4b08      	ldr	r3, [pc, #32]	; (60001718 <myPitchBend(unsigned char, int)+0x98>)
600016f8:	e7e6      	b.n	600016c8 <myPitchBend(unsigned char, int)+0x48>
600016fa:	bf00      	nop
600016fc:	20004df4 	.word	0x20004df4
60001700:	20004e40 	.word	0x20004e40
60001704:	3daaaaab 	.word	0x3daaaaab
60001708:	39000000 	.word	0x39000000
6000170c:	7fff0000 	.word	0x7fff0000
60001710:	20013214 	.word	0x20013214
60001714:	4efffe00 	.word	0x4efffe00
60001718:	80010000 	.word	0x80010000

6000171c <myMIDIClockStart()>:
		oscTranspose = 0;
		oscMasterTune = 1.0f;
		PitchWheelAmt = 1.0f;
		PitchWheelvalue = 127;
		MODWheelAmt = 1.0f;
		MODWheelvalue = 127;
6000171c:	4b08      	ldr	r3, [pc, #32]	; (60001740 <myMIDIClockStart()+0x24>)
		/* 67 */ WShaperDrive = 1.00f;
		if (WShaperDrive == 0) {
			WShaperDrive = 1.0f;
		}
		LFO1phase = 0.0f;
		LFO2phase = 0.0f;
6000171e:	2101      	movs	r1, #1
60001720:	4a08      	ldr	r2, [pc, #32]	; (60001744 <myMIDIClockStart()+0x28>)
		oscTranspose = 0;
		oscMasterTune = 1.0f;
		PitchWheelAmt = 1.0f;
		PitchWheelvalue = 127;
		MODWheelAmt = 1.0f;
		MODWheelvalue = 127;
60001722:	681b      	ldr	r3, [r3, #0]
		/* 67 */ WShaperDrive = 1.00f;
		if (WShaperDrive == 0) {
			WShaperDrive = 1.0f;
		}
		LFO1phase = 0.0f;
		LFO2phase = 0.0f;
60001724:	7011      	strb	r1, [r2, #0]
		oscTranspose = 0;
		oscMasterTune = 1.0f;
		PitchWheelAmt = 1.0f;
		PitchWheelvalue = 127;
		MODWheelAmt = 1.0f;
		MODWheelvalue = 127;
60001726:	428b      	cmp	r3, r1
60001728:	d006      	beq.n	60001738 <myMIDIClockStart()+0x1c>
		
		
		// Update Parameter
6000172a:	4b07      	ldr	r3, [pc, #28]	; (60001748 <myMIDIClockStart()+0x2c>)
6000172c:	681b      	ldr	r3, [r3, #0]
6000172e:	2b01      	cmp	r3, #1
60001730:	d101      	bne.n	60001736 <myMIDIClockStart()+0x1a>
      if (angle >= 360.0) return;
    }
    phase_offset = angle * (4294967296.0 / 360.0);
  }
  void sync() {
    syncFlag = 1;
60001732:	4a06      	ldr	r2, [pc, #24]	; (6000174c <myMIDIClockStart()+0x30>)
60001734:	86d3      	strh	r3, [r2, #54]	; 0x36
60001736:	4770      	bx	lr
60001738:	4a05      	ldr	r2, [pc, #20]	; (60001750 <myMIDIClockStart()+0x34>)
6000173a:	86d3      	strh	r3, [r2, #54]	; 0x36
6000173c:	e7f5      	b.n	6000172a <myMIDIClockStart()+0xe>
6000173e:	bf00      	nop
60001740:	20007a88 	.word	0x20007a88
60001744:	200080c8 	.word	0x200080c8
60001748:	20010cd4 	.word	0x20010cd4
6000174c:	200125ac 	.word	0x200125ac
60001750:	20012400 	.word	0x20012400

60001754 <myMIDIClockStop()>:
		updatePatchname();
		updateUnison();
		updateWaveformA();
		updateWaveformB();
		updatePitchA();
		updatePitchB();
60001754:	4b01      	ldr	r3, [pc, #4]	; (6000175c <myMIDIClockStop()+0x8>)
60001756:	2200      	movs	r2, #0
60001758:	701a      	strb	r2, [r3, #0]
6000175a:	4770      	bx	lr
6000175c:	200080c8 	.word	0x200080c8

60001760 <setFilterModMixer(int, float) [clone .constprop.166]>:
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001760:	eddf 7a78 	vldr	s15, [pc, #480]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
60001764:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001768:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000176c:	f300 80aa 	bgt.w	600018c4 <setFilterModMixer(int, float) [clone .constprop.166]+0x164>
		else if (gain < -32767.0f) gain = -32767.0f;
60001770:	ed9f 7a75 	vldr	s14, [pc, #468]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
60001774:	eeb4 0ac7 	vcmpe.f32	s0, s14
60001778:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000177c:	f100 80b9 	bmi.w	600018f2 <setFilterModMixer(int, float) [clone .constprop.166]+0x192>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001780:	eef0 6a40 	vmov.f32	s13, s0
60001784:	4a71      	ldr	r2, [pc, #452]	; (6000194c <setFilterModMixer(int, float) [clone .constprop.166]+0x1ec>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001786:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000178a:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000178e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001792:	ee16 3a90 	vmov	r3, s13
60001796:	edc2 6a08 	vstr	s13, [r2, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000179a:	f300 80b3 	bgt.w	60001904 <setFilterModMixer(int, float) [clone .constprop.166]+0x1a4>
6000179e:	eeb4 0ac7 	vcmpe.f32	s0, s14
600017a2:	4a6b      	ldr	r2, [pc, #428]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
600017a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600017a8:	bf48      	it	mi
600017aa:	4613      	movmi	r3, r2
600017ac:	eddf 7a65 	vldr	s15, [pc, #404]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600017b0:	4a68      	ldr	r2, [pc, #416]	; (60001954 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f4>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600017b2:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600017b6:	6213      	str	r3, [r2, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600017b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600017bc:	f300 8087 	bgt.w	600018ce <setFilterModMixer(int, float) [clone .constprop.166]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
600017c0:	eddf 7a61 	vldr	s15, [pc, #388]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
600017c4:	eeb4 0ae7 	vcmpe.f32	s0, s15
600017c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600017cc:	f100 808f 	bmi.w	600018ee <setFilterModMixer(int, float) [clone .constprop.166]+0x18e>
600017d0:	eef0 7a40 	vmov.f32	s15, s0
600017d4:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600017d8:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600017dc:	eddf 7a59 	vldr	s15, [pc, #356]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600017e0:	4b5d      	ldr	r3, [pc, #372]	; (60001958 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600017e2:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600017e6:	621a      	str	r2, [r3, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600017e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600017ec:	f300 808f 	bgt.w	6000190e <setFilterModMixer(int, float) [clone .constprop.166]+0x1ae>
		else if (gain < -32767.0f) gain = -32767.0f;
600017f0:	eddf 7a55 	vldr	s15, [pc, #340]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
600017f4:	eeb4 0ae7 	vcmpe.f32	s0, s15
600017f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600017fc:	f100 809d 	bmi.w	6000193a <setFilterModMixer(int, float) [clone .constprop.166]+0x1da>
60001800:	eef0 7a40 	vmov.f32	s15, s0
60001804:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001808:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000180c:	eddf 7a4d 	vldr	s15, [pc, #308]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001810:	4b52      	ldr	r3, [pc, #328]	; (6000195c <setFilterModMixer(int, float) [clone .constprop.166]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001812:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001816:	621a      	str	r2, [r3, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001818:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000181c:	dc5c      	bgt.n	600018d8 <setFilterModMixer(int, float) [clone .constprop.166]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
6000181e:	eddf 7a4a 	vldr	s15, [pc, #296]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
60001822:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001826:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000182a:	f100 8084 	bmi.w	60001936 <setFilterModMixer(int, float) [clone .constprop.166]+0x1d6>
6000182e:	eef0 7a40 	vmov.f32	s15, s0
60001832:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001836:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000183a:	eddf 7a42 	vldr	s15, [pc, #264]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000183e:	4b48      	ldr	r3, [pc, #288]	; (60001960 <setFilterModMixer(int, float) [clone .constprop.166]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001840:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001844:	621a      	str	r2, [r3, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000184a:	dc65      	bgt.n	60001918 <setFilterModMixer(int, float) [clone .constprop.166]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
6000184c:	eddf 7a3e 	vldr	s15, [pc, #248]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
60001850:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001854:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001858:	d46b      	bmi.n	60001932 <setFilterModMixer(int, float) [clone .constprop.166]+0x1d2>
6000185a:	eef0 7a40 	vmov.f32	s15, s0
6000185e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001862:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001866:	eddf 7a37 	vldr	s15, [pc, #220]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000186a:	4b3e      	ldr	r3, [pc, #248]	; (60001964 <setFilterModMixer(int, float) [clone .constprop.166]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000186c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001870:	621a      	str	r2, [r3, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001876:	dc34      	bgt.n	600018e2 <setFilterModMixer(int, float) [clone .constprop.166]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
60001878:	eddf 7a33 	vldr	s15, [pc, #204]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
6000187c:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001884:	d453      	bmi.n	6000192e <setFilterModMixer(int, float) [clone .constprop.166]+0x1ce>
60001886:	eef0 7a40 	vmov.f32	s15, s0
6000188a:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
6000188e:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001892:	eddf 7a2c 	vldr	s15, [pc, #176]	; 60001944 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001896:	4b34      	ldr	r3, [pc, #208]	; (60001968 <setFilterModMixer(int, float) [clone .constprop.166]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001898:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000189c:	621a      	str	r2, [r3, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000189e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600018a2:	dc4c      	bgt.n	6000193e <setFilterModMixer(int, float) [clone .constprop.166]+0x1de>
		else if (gain < -32767.0f) gain = -32767.0f;
600018a4:	eddf 7a28 	vldr	s15, [pc, #160]	; 60001948 <setFilterModMixer(int, float) [clone .constprop.166]+0x1e8>
600018a8:	eeb4 0ae7 	vcmpe.f32	s0, s15
600018ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600018b0:	d439      	bmi.n	60001926 <setFilterModMixer(int, float) [clone .constprop.166]+0x1c6>
600018b2:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600018b6:	4a2d      	ldr	r2, [pc, #180]	; (6000196c <setFilterModMixer(int, float) [clone .constprop.166]+0x20c>)
600018b8:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600018bc:	ee17 3a90 	vmov	r3, s15
600018c0:	6213      	str	r3, [r2, #32]
600018c2:	4770      	bx	lr
600018c4:	4b2a      	ldr	r3, [pc, #168]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
600018c6:	4921      	ldr	r1, [pc, #132]	; (6000194c <setFilterModMixer(int, float) [clone .constprop.166]+0x1ec>)
600018c8:	4a22      	ldr	r2, [pc, #136]	; (60001954 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f4>)
600018ca:	620b      	str	r3, [r1, #32]
600018cc:	6213      	str	r3, [r2, #32]
600018ce:	4b28      	ldr	r3, [pc, #160]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
600018d0:	4921      	ldr	r1, [pc, #132]	; (60001958 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f8>)
600018d2:	4a22      	ldr	r2, [pc, #136]	; (6000195c <setFilterModMixer(int, float) [clone .constprop.166]+0x1fc>)
600018d4:	620b      	str	r3, [r1, #32]
600018d6:	6213      	str	r3, [r2, #32]
600018d8:	4b25      	ldr	r3, [pc, #148]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
600018da:	4921      	ldr	r1, [pc, #132]	; (60001960 <setFilterModMixer(int, float) [clone .constprop.166]+0x200>)
600018dc:	4a21      	ldr	r2, [pc, #132]	; (60001964 <setFilterModMixer(int, float) [clone .constprop.166]+0x204>)
600018de:	620b      	str	r3, [r1, #32]
600018e0:	6213      	str	r3, [r2, #32]
600018e2:	4a21      	ldr	r2, [pc, #132]	; (60001968 <setFilterModMixer(int, float) [clone .constprop.166]+0x208>)
600018e4:	4b22      	ldr	r3, [pc, #136]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
600018e6:	6213      	str	r3, [r2, #32]
600018e8:	4a20      	ldr	r2, [pc, #128]	; (6000196c <setFilterModMixer(int, float) [clone .constprop.166]+0x20c>)
600018ea:	6213      	str	r3, [r2, #32]
600018ec:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
600018ee:	4a18      	ldr	r2, [pc, #96]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
600018f0:	e774      	b.n	600017dc <setFilterModMixer(int, float) [clone .constprop.166]+0x7c>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600018f2:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600018f6:	4a15      	ldr	r2, [pc, #84]	; (6000194c <setFilterModMixer(int, float) [clone .constprop.166]+0x1ec>)
600018f8:	4b15      	ldr	r3, [pc, #84]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600018fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600018fe:	6213      	str	r3, [r2, #32]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001900:	f77f af54 	ble.w	600017ac <setFilterModMixer(int, float) [clone .constprop.166]+0x4c>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001904:	4b1a      	ldr	r3, [pc, #104]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
60001906:	4913      	ldr	r1, [pc, #76]	; (60001954 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f4>)
60001908:	4a13      	ldr	r2, [pc, #76]	; (60001958 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f8>)
6000190a:	620b      	str	r3, [r1, #32]
6000190c:	6213      	str	r3, [r2, #32]
6000190e:	4b18      	ldr	r3, [pc, #96]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
60001910:	4912      	ldr	r1, [pc, #72]	; (6000195c <setFilterModMixer(int, float) [clone .constprop.166]+0x1fc>)
60001912:	4a13      	ldr	r2, [pc, #76]	; (60001960 <setFilterModMixer(int, float) [clone .constprop.166]+0x200>)
60001914:	620b      	str	r3, [r1, #32]
60001916:	6213      	str	r3, [r2, #32]
60001918:	4a15      	ldr	r2, [pc, #84]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
6000191a:	4b12      	ldr	r3, [pc, #72]	; (60001964 <setFilterModMixer(int, float) [clone .constprop.166]+0x204>)
6000191c:	4912      	ldr	r1, [pc, #72]	; (60001968 <setFilterModMixer(int, float) [clone .constprop.166]+0x208>)
6000191e:	621a      	str	r2, [r3, #32]
60001920:	4613      	mov	r3, r2
60001922:	620a      	str	r2, [r1, #32]
60001924:	e7e0      	b.n	600018e8 <setFilterModMixer(int, float) [clone .constprop.166]+0x188>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001926:	4b0a      	ldr	r3, [pc, #40]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001928:	4a10      	ldr	r2, [pc, #64]	; (6000196c <setFilterModMixer(int, float) [clone .constprop.166]+0x20c>)
6000192a:	6213      	str	r3, [r2, #32]
6000192c:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
6000192e:	4a08      	ldr	r2, [pc, #32]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
60001930:	e7af      	b.n	60001892 <setFilterModMixer(int, float) [clone .constprop.166]+0x132>
60001932:	4a07      	ldr	r2, [pc, #28]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
60001934:	e797      	b.n	60001866 <setFilterModMixer(int, float) [clone .constprop.166]+0x106>
60001936:	4a06      	ldr	r2, [pc, #24]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
60001938:	e77f      	b.n	6000183a <setFilterModMixer(int, float) [clone .constprop.166]+0xda>
6000193a:	4a05      	ldr	r2, [pc, #20]	; (60001950 <setFilterModMixer(int, float) [clone .constprop.166]+0x1f0>)
6000193c:	e766      	b.n	6000180c <setFilterModMixer(int, float) [clone .constprop.166]+0xac>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000193e:	4b0c      	ldr	r3, [pc, #48]	; (60001970 <setFilterModMixer(int, float) [clone .constprop.166]+0x210>)
60001940:	e7d2      	b.n	600018e8 <setFilterModMixer(int, float) [clone .constprop.166]+0x188>
60001942:	bf00      	nop
60001944:	46fffe00 	.word	0x46fffe00
60001948:	c6fffe00 	.word	0xc6fffe00
6000194c:	200121fc 	.word	0x200121fc
60001950:	80010000 	.word	0x80010000
60001954:	20012234 	.word	0x20012234
60001958:	2001226c 	.word	0x2001226c
6000195c:	200122a4 	.word	0x200122a4
60001960:	200122dc 	.word	0x200122dc
60001964:	20012314 	.word	0x20012314
60001968:	2001234c 	.word	0x2001234c
6000196c:	20012384 	.word	0x20012384
60001970:	7fff0000 	.word	0x7fff0000

60001974 <setFilterModMixer(int, float) [clone .constprop.167]>:
60001974:	eddf 7a78 	vldr	s15, [pc, #480]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
60001978:	eeb4 0ae7 	vcmpe.f32	s0, s15
6000197c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001980:	f300 80aa 	bgt.w	60001ad8 <setFilterModMixer(int, float) [clone .constprop.167]+0x164>
		else if (gain < -32767.0f) gain = -32767.0f;
60001984:	ed9f 7a75 	vldr	s14, [pc, #468]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
60001988:	eeb4 0ac7 	vcmpe.f32	s0, s14
6000198c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001990:	f100 80b9 	bmi.w	60001b06 <setFilterModMixer(int, float) [clone .constprop.167]+0x192>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001994:	eef0 6a40 	vmov.f32	s13, s0
60001998:	4a71      	ldr	r2, [pc, #452]	; (60001b60 <setFilterModMixer(int, float) [clone .constprop.167]+0x1ec>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000199a:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000199e:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600019a6:	ee16 3a90 	vmov	r3, s13
600019aa:	edc2 6a06 	vstr	s13, [r2, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019ae:	f300 80b3 	bgt.w	60001b18 <setFilterModMixer(int, float) [clone .constprop.167]+0x1a4>
600019b2:	eeb4 0ac7 	vcmpe.f32	s0, s14
600019b6:	4a6b      	ldr	r2, [pc, #428]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
600019b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600019bc:	bf48      	it	mi
600019be:	4613      	movmi	r3, r2
600019c0:	eddf 7a65 	vldr	s15, [pc, #404]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600019c4:	4a68      	ldr	r2, [pc, #416]	; (60001b68 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f4>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019c6:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600019ca:	6193      	str	r3, [r2, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600019d0:	f300 8087 	bgt.w	60001ae2 <setFilterModMixer(int, float) [clone .constprop.167]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
600019d4:	eddf 7a61 	vldr	s15, [pc, #388]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
600019d8:	eeb4 0ae7 	vcmpe.f32	s0, s15
600019dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600019e0:	f100 808f 	bmi.w	60001b02 <setFilterModMixer(int, float) [clone .constprop.167]+0x18e>
600019e4:	eef0 7a40 	vmov.f32	s15, s0
600019e8:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600019ec:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019f0:	eddf 7a59 	vldr	s15, [pc, #356]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600019f4:	4b5d      	ldr	r3, [pc, #372]	; (60001b6c <setFilterModMixer(int, float) [clone .constprop.167]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019f6:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600019fa:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600019fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a00:	f300 808f 	bgt.w	60001b22 <setFilterModMixer(int, float) [clone .constprop.167]+0x1ae>
		else if (gain < -32767.0f) gain = -32767.0f;
60001a04:	eddf 7a55 	vldr	s15, [pc, #340]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
60001a08:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001a0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a10:	f100 809d 	bmi.w	60001b4e <setFilterModMixer(int, float) [clone .constprop.167]+0x1da>
60001a14:	eef0 7a40 	vmov.f32	s15, s0
60001a18:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001a1c:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a20:	eddf 7a4d 	vldr	s15, [pc, #308]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001a24:	4b52      	ldr	r3, [pc, #328]	; (60001b70 <setFilterModMixer(int, float) [clone .constprop.167]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a26:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001a2a:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a30:	dc5c      	bgt.n	60001aec <setFilterModMixer(int, float) [clone .constprop.167]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
60001a32:	eddf 7a4a 	vldr	s15, [pc, #296]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
60001a36:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001a3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a3e:	f100 8084 	bmi.w	60001b4a <setFilterModMixer(int, float) [clone .constprop.167]+0x1d6>
60001a42:	eef0 7a40 	vmov.f32	s15, s0
60001a46:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001a4a:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a4e:	eddf 7a42 	vldr	s15, [pc, #264]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001a52:	4b48      	ldr	r3, [pc, #288]	; (60001b74 <setFilterModMixer(int, float) [clone .constprop.167]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a54:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001a58:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a5e:	dc65      	bgt.n	60001b2c <setFilterModMixer(int, float) [clone .constprop.167]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
60001a60:	eddf 7a3e 	vldr	s15, [pc, #248]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
60001a64:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001a68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a6c:	d46b      	bmi.n	60001b46 <setFilterModMixer(int, float) [clone .constprop.167]+0x1d2>
60001a6e:	eef0 7a40 	vmov.f32	s15, s0
60001a72:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001a76:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a7a:	eddf 7a37 	vldr	s15, [pc, #220]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001a7e:	4b3e      	ldr	r3, [pc, #248]	; (60001b78 <setFilterModMixer(int, float) [clone .constprop.167]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a80:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001a84:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001a86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a8a:	dc34      	bgt.n	60001af6 <setFilterModMixer(int, float) [clone .constprop.167]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
60001a8c:	eddf 7a33 	vldr	s15, [pc, #204]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
60001a90:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001a94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001a98:	d453      	bmi.n	60001b42 <setFilterModMixer(int, float) [clone .constprop.167]+0x1ce>
60001a9a:	eef0 7a40 	vmov.f32	s15, s0
60001a9e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001aa2:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001aa6:	eddf 7a2c 	vldr	s15, [pc, #176]	; 60001b58 <setFilterModMixer(int, float) [clone .constprop.167]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001aaa:	4b34      	ldr	r3, [pc, #208]	; (60001b7c <setFilterModMixer(int, float) [clone .constprop.167]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001aac:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001ab0:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001ab2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001ab6:	dc4c      	bgt.n	60001b52 <setFilterModMixer(int, float) [clone .constprop.167]+0x1de>
		else if (gain < -32767.0f) gain = -32767.0f;
60001ab8:	eddf 7a28 	vldr	s15, [pc, #160]	; 60001b5c <setFilterModMixer(int, float) [clone .constprop.167]+0x1e8>
60001abc:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001ac0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001ac4:	d439      	bmi.n	60001b3a <setFilterModMixer(int, float) [clone .constprop.167]+0x1c6>
60001ac6:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001aca:	4a2d      	ldr	r2, [pc, #180]	; (60001b80 <setFilterModMixer(int, float) [clone .constprop.167]+0x20c>)
60001acc:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001ad0:	ee17 3a90 	vmov	r3, s15
60001ad4:	6193      	str	r3, [r2, #24]
60001ad6:	4770      	bx	lr
60001ad8:	4b2a      	ldr	r3, [pc, #168]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001ada:	4921      	ldr	r1, [pc, #132]	; (60001b60 <setFilterModMixer(int, float) [clone .constprop.167]+0x1ec>)
60001adc:	4a22      	ldr	r2, [pc, #136]	; (60001b68 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f4>)
60001ade:	618b      	str	r3, [r1, #24]
60001ae0:	6193      	str	r3, [r2, #24]
60001ae2:	4b28      	ldr	r3, [pc, #160]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001ae4:	4921      	ldr	r1, [pc, #132]	; (60001b6c <setFilterModMixer(int, float) [clone .constprop.167]+0x1f8>)
60001ae6:	4a22      	ldr	r2, [pc, #136]	; (60001b70 <setFilterModMixer(int, float) [clone .constprop.167]+0x1fc>)
60001ae8:	618b      	str	r3, [r1, #24]
60001aea:	6193      	str	r3, [r2, #24]
60001aec:	4b25      	ldr	r3, [pc, #148]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001aee:	4921      	ldr	r1, [pc, #132]	; (60001b74 <setFilterModMixer(int, float) [clone .constprop.167]+0x200>)
60001af0:	4a21      	ldr	r2, [pc, #132]	; (60001b78 <setFilterModMixer(int, float) [clone .constprop.167]+0x204>)
60001af2:	618b      	str	r3, [r1, #24]
60001af4:	6193      	str	r3, [r2, #24]
60001af6:	4a21      	ldr	r2, [pc, #132]	; (60001b7c <setFilterModMixer(int, float) [clone .constprop.167]+0x208>)
60001af8:	4b22      	ldr	r3, [pc, #136]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001afa:	6193      	str	r3, [r2, #24]
60001afc:	4a20      	ldr	r2, [pc, #128]	; (60001b80 <setFilterModMixer(int, float) [clone .constprop.167]+0x20c>)
60001afe:	6193      	str	r3, [r2, #24]
60001b00:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001b02:	4a18      	ldr	r2, [pc, #96]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
60001b04:	e774      	b.n	600019f0 <setFilterModMixer(int, float) [clone .constprop.167]+0x7c>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001b06:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001b0a:	4a15      	ldr	r2, [pc, #84]	; (60001b60 <setFilterModMixer(int, float) [clone .constprop.167]+0x1ec>)
60001b0c:	4b15      	ldr	r3, [pc, #84]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001b0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001b12:	6193      	str	r3, [r2, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001b14:	f77f af54 	ble.w	600019c0 <setFilterModMixer(int, float) [clone .constprop.167]+0x4c>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001b18:	4b1a      	ldr	r3, [pc, #104]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001b1a:	4913      	ldr	r1, [pc, #76]	; (60001b68 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f4>)
60001b1c:	4a13      	ldr	r2, [pc, #76]	; (60001b6c <setFilterModMixer(int, float) [clone .constprop.167]+0x1f8>)
60001b1e:	618b      	str	r3, [r1, #24]
60001b20:	6193      	str	r3, [r2, #24]
60001b22:	4b18      	ldr	r3, [pc, #96]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001b24:	4912      	ldr	r1, [pc, #72]	; (60001b70 <setFilterModMixer(int, float) [clone .constprop.167]+0x1fc>)
60001b26:	4a13      	ldr	r2, [pc, #76]	; (60001b74 <setFilterModMixer(int, float) [clone .constprop.167]+0x200>)
60001b28:	618b      	str	r3, [r1, #24]
60001b2a:	6193      	str	r3, [r2, #24]
60001b2c:	4a15      	ldr	r2, [pc, #84]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001b2e:	4b12      	ldr	r3, [pc, #72]	; (60001b78 <setFilterModMixer(int, float) [clone .constprop.167]+0x204>)
60001b30:	4912      	ldr	r1, [pc, #72]	; (60001b7c <setFilterModMixer(int, float) [clone .constprop.167]+0x208>)
60001b32:	619a      	str	r2, [r3, #24]
60001b34:	4613      	mov	r3, r2
60001b36:	618a      	str	r2, [r1, #24]
60001b38:	e7e0      	b.n	60001afc <setFilterModMixer(int, float) [clone .constprop.167]+0x188>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001b3a:	4b0a      	ldr	r3, [pc, #40]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001b3c:	4a10      	ldr	r2, [pc, #64]	; (60001b80 <setFilterModMixer(int, float) [clone .constprop.167]+0x20c>)
60001b3e:	6193      	str	r3, [r2, #24]
60001b40:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001b42:	4a08      	ldr	r2, [pc, #32]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
60001b44:	e7af      	b.n	60001aa6 <setFilterModMixer(int, float) [clone .constprop.167]+0x132>
60001b46:	4a07      	ldr	r2, [pc, #28]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
60001b48:	e797      	b.n	60001a7a <setFilterModMixer(int, float) [clone .constprop.167]+0x106>
60001b4a:	4a06      	ldr	r2, [pc, #24]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
60001b4c:	e77f      	b.n	60001a4e <setFilterModMixer(int, float) [clone .constprop.167]+0xda>
60001b4e:	4a05      	ldr	r2, [pc, #20]	; (60001b64 <setFilterModMixer(int, float) [clone .constprop.167]+0x1f0>)
60001b50:	e766      	b.n	60001a20 <setFilterModMixer(int, float) [clone .constprop.167]+0xac>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001b52:	4b0c      	ldr	r3, [pc, #48]	; (60001b84 <setFilterModMixer(int, float) [clone .constprop.167]+0x210>)
60001b54:	e7d2      	b.n	60001afc <setFilterModMixer(int, float) [clone .constprop.167]+0x188>
60001b56:	bf00      	nop
60001b58:	46fffe00 	.word	0x46fffe00
60001b5c:	c6fffe00 	.word	0xc6fffe00
60001b60:	200121fc 	.word	0x200121fc
60001b64:	80010000 	.word	0x80010000
60001b68:	20012234 	.word	0x20012234
60001b6c:	2001226c 	.word	0x2001226c
60001b70:	200122a4 	.word	0x200122a4
60001b74:	200122dc 	.word	0x200122dc
60001b78:	20012314 	.word	0x20012314
60001b7c:	2001234c 	.word	0x2001234c
60001b80:	20012384 	.word	0x20012384
60001b84:	7fff0000 	.word	0x7fff0000

60001b88 <setOscModMixerB(int, float) [clone .constprop.168]>:
60001b88:	eddf 7a78 	vldr	s15, [pc, #480]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
60001b8c:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001b90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001b94:	f300 80aa 	bgt.w	60001cec <setOscModMixerB(int, float) [clone .constprop.168]+0x164>
		else if (gain < -32767.0f) gain = -32767.0f;
60001b98:	ed9f 7a75 	vldr	s14, [pc, #468]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001b9c:	eeb4 0ac7 	vcmpe.f32	s0, s14
60001ba0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001ba4:	f100 80b9 	bmi.w	60001d1a <setOscModMixerB(int, float) [clone .constprop.168]+0x192>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001ba8:	eef0 6a40 	vmov.f32	s13, s0
60001bac:	4a71      	ldr	r2, [pc, #452]	; (60001d74 <setOscModMixerB(int, float) [clone .constprop.168]+0x1ec>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001bae:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001bb2:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001bb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001bba:	ee16 3a90 	vmov	r3, s13
60001bbe:	edc2 6a09 	vstr	s13, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001bc2:	f300 80b3 	bgt.w	60001d2c <setOscModMixerB(int, float) [clone .constprop.168]+0x1a4>
60001bc6:	eeb4 0ac7 	vcmpe.f32	s0, s14
60001bca:	4a6b      	ldr	r2, [pc, #428]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
60001bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001bd0:	bf48      	it	mi
60001bd2:	4613      	movmi	r3, r2
60001bd4:	eddf 7a65 	vldr	s15, [pc, #404]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001bd8:	4a68      	ldr	r2, [pc, #416]	; (60001d7c <setOscModMixerB(int, float) [clone .constprop.168]+0x1f4>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001bda:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001bde:	6253      	str	r3, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001be0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001be4:	f300 8087 	bgt.w	60001cf6 <setOscModMixerB(int, float) [clone .constprop.168]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
60001be8:	eddf 7a61 	vldr	s15, [pc, #388]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001bec:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001bf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001bf4:	f100 808f 	bmi.w	60001d16 <setOscModMixerB(int, float) [clone .constprop.168]+0x18e>
60001bf8:	eef0 7a40 	vmov.f32	s15, s0
60001bfc:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001c00:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c04:	eddf 7a59 	vldr	s15, [pc, #356]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c08:	4b5d      	ldr	r3, [pc, #372]	; (60001d80 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c0a:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c0e:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c14:	f300 808f 	bgt.w	60001d36 <setOscModMixerB(int, float) [clone .constprop.168]+0x1ae>
		else if (gain < -32767.0f) gain = -32767.0f;
60001c18:	eddf 7a55 	vldr	s15, [pc, #340]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001c1c:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001c20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c24:	f100 809d 	bmi.w	60001d62 <setOscModMixerB(int, float) [clone .constprop.168]+0x1da>
60001c28:	eef0 7a40 	vmov.f32	s15, s0
60001c2c:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001c30:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c34:	eddf 7a4d 	vldr	s15, [pc, #308]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c38:	4b52      	ldr	r3, [pc, #328]	; (60001d84 <setOscModMixerB(int, float) [clone .constprop.168]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c3a:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c3e:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c44:	dc5c      	bgt.n	60001d00 <setOscModMixerB(int, float) [clone .constprop.168]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
60001c46:	eddf 7a4a 	vldr	s15, [pc, #296]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001c4a:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001c4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c52:	f100 8084 	bmi.w	60001d5e <setOscModMixerB(int, float) [clone .constprop.168]+0x1d6>
60001c56:	eef0 7a40 	vmov.f32	s15, s0
60001c5a:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001c5e:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c62:	eddf 7a42 	vldr	s15, [pc, #264]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c66:	4b48      	ldr	r3, [pc, #288]	; (60001d88 <setOscModMixerB(int, float) [clone .constprop.168]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c68:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c6c:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c72:	dc65      	bgt.n	60001d40 <setOscModMixerB(int, float) [clone .constprop.168]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
60001c74:	eddf 7a3e 	vldr	s15, [pc, #248]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001c78:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001c7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c80:	d46b      	bmi.n	60001d5a <setOscModMixerB(int, float) [clone .constprop.168]+0x1d2>
60001c82:	eef0 7a40 	vmov.f32	s15, s0
60001c86:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001c8a:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c8e:	eddf 7a37 	vldr	s15, [pc, #220]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c92:	4b3e      	ldr	r3, [pc, #248]	; (60001d8c <setOscModMixerB(int, float) [clone .constprop.168]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c94:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001c98:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001c9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001c9e:	dc34      	bgt.n	60001d0a <setOscModMixerB(int, float) [clone .constprop.168]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
60001ca0:	eddf 7a33 	vldr	s15, [pc, #204]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001ca4:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001ca8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001cac:	d453      	bmi.n	60001d56 <setOscModMixerB(int, float) [clone .constprop.168]+0x1ce>
60001cae:	eef0 7a40 	vmov.f32	s15, s0
60001cb2:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001cb6:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001cba:	eddf 7a2c 	vldr	s15, [pc, #176]	; 60001d6c <setOscModMixerB(int, float) [clone .constprop.168]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001cbe:	4b34      	ldr	r3, [pc, #208]	; (60001d90 <setOscModMixerB(int, float) [clone .constprop.168]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001cc0:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001cc4:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001cc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001cca:	dc4c      	bgt.n	60001d66 <setOscModMixerB(int, float) [clone .constprop.168]+0x1de>
		else if (gain < -32767.0f) gain = -32767.0f;
60001ccc:	eddf 7a28 	vldr	s15, [pc, #160]	; 60001d70 <setOscModMixerB(int, float) [clone .constprop.168]+0x1e8>
60001cd0:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001cd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001cd8:	d439      	bmi.n	60001d4e <setOscModMixerB(int, float) [clone .constprop.168]+0x1c6>
60001cda:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001cde:	4a2d      	ldr	r2, [pc, #180]	; (60001d94 <setOscModMixerB(int, float) [clone .constprop.168]+0x20c>)
60001ce0:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001ce4:	ee17 3a90 	vmov	r3, s15
60001ce8:	6253      	str	r3, [r2, #36]	; 0x24
60001cea:	4770      	bx	lr
60001cec:	4b2a      	ldr	r3, [pc, #168]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001cee:	4921      	ldr	r1, [pc, #132]	; (60001d74 <setOscModMixerB(int, float) [clone .constprop.168]+0x1ec>)
60001cf0:	4a22      	ldr	r2, [pc, #136]	; (60001d7c <setOscModMixerB(int, float) [clone .constprop.168]+0x1f4>)
60001cf2:	624b      	str	r3, [r1, #36]	; 0x24
60001cf4:	6253      	str	r3, [r2, #36]	; 0x24
60001cf6:	4b28      	ldr	r3, [pc, #160]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001cf8:	4921      	ldr	r1, [pc, #132]	; (60001d80 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f8>)
60001cfa:	4a22      	ldr	r2, [pc, #136]	; (60001d84 <setOscModMixerB(int, float) [clone .constprop.168]+0x1fc>)
60001cfc:	624b      	str	r3, [r1, #36]	; 0x24
60001cfe:	6253      	str	r3, [r2, #36]	; 0x24
60001d00:	4b25      	ldr	r3, [pc, #148]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001d02:	4921      	ldr	r1, [pc, #132]	; (60001d88 <setOscModMixerB(int, float) [clone .constprop.168]+0x200>)
60001d04:	4a21      	ldr	r2, [pc, #132]	; (60001d8c <setOscModMixerB(int, float) [clone .constprop.168]+0x204>)
60001d06:	624b      	str	r3, [r1, #36]	; 0x24
60001d08:	6253      	str	r3, [r2, #36]	; 0x24
60001d0a:	4a21      	ldr	r2, [pc, #132]	; (60001d90 <setOscModMixerB(int, float) [clone .constprop.168]+0x208>)
60001d0c:	4b22      	ldr	r3, [pc, #136]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001d0e:	6253      	str	r3, [r2, #36]	; 0x24
60001d10:	4a20      	ldr	r2, [pc, #128]	; (60001d94 <setOscModMixerB(int, float) [clone .constprop.168]+0x20c>)
60001d12:	6253      	str	r3, [r2, #36]	; 0x24
60001d14:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001d16:	4a18      	ldr	r2, [pc, #96]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
60001d18:	e774      	b.n	60001c04 <setOscModMixerB(int, float) [clone .constprop.168]+0x7c>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001d1a:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001d1e:	4a15      	ldr	r2, [pc, #84]	; (60001d74 <setOscModMixerB(int, float) [clone .constprop.168]+0x1ec>)
60001d20:	4b15      	ldr	r3, [pc, #84]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001d22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001d26:	6253      	str	r3, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001d28:	f77f af54 	ble.w	60001bd4 <setOscModMixerB(int, float) [clone .constprop.168]+0x4c>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001d2c:	4b1a      	ldr	r3, [pc, #104]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001d2e:	4913      	ldr	r1, [pc, #76]	; (60001d7c <setOscModMixerB(int, float) [clone .constprop.168]+0x1f4>)
60001d30:	4a13      	ldr	r2, [pc, #76]	; (60001d80 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f8>)
60001d32:	624b      	str	r3, [r1, #36]	; 0x24
60001d34:	6253      	str	r3, [r2, #36]	; 0x24
60001d36:	4b18      	ldr	r3, [pc, #96]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001d38:	4912      	ldr	r1, [pc, #72]	; (60001d84 <setOscModMixerB(int, float) [clone .constprop.168]+0x1fc>)
60001d3a:	4a13      	ldr	r2, [pc, #76]	; (60001d88 <setOscModMixerB(int, float) [clone .constprop.168]+0x200>)
60001d3c:	624b      	str	r3, [r1, #36]	; 0x24
60001d3e:	6253      	str	r3, [r2, #36]	; 0x24
60001d40:	4a15      	ldr	r2, [pc, #84]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001d42:	4b12      	ldr	r3, [pc, #72]	; (60001d8c <setOscModMixerB(int, float) [clone .constprop.168]+0x204>)
60001d44:	4912      	ldr	r1, [pc, #72]	; (60001d90 <setOscModMixerB(int, float) [clone .constprop.168]+0x208>)
60001d46:	625a      	str	r2, [r3, #36]	; 0x24
60001d48:	4613      	mov	r3, r2
60001d4a:	624a      	str	r2, [r1, #36]	; 0x24
60001d4c:	e7e0      	b.n	60001d10 <setOscModMixerB(int, float) [clone .constprop.168]+0x188>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001d4e:	4b0a      	ldr	r3, [pc, #40]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001d50:	4a10      	ldr	r2, [pc, #64]	; (60001d94 <setOscModMixerB(int, float) [clone .constprop.168]+0x20c>)
60001d52:	6253      	str	r3, [r2, #36]	; 0x24
60001d54:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001d56:	4a08      	ldr	r2, [pc, #32]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
60001d58:	e7af      	b.n	60001cba <setOscModMixerB(int, float) [clone .constprop.168]+0x132>
60001d5a:	4a07      	ldr	r2, [pc, #28]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
60001d5c:	e797      	b.n	60001c8e <setOscModMixerB(int, float) [clone .constprop.168]+0x106>
60001d5e:	4a06      	ldr	r2, [pc, #24]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
60001d60:	e77f      	b.n	60001c62 <setOscModMixerB(int, float) [clone .constprop.168]+0xda>
60001d62:	4a05      	ldr	r2, [pc, #20]	; (60001d78 <setOscModMixerB(int, float) [clone .constprop.168]+0x1f0>)
60001d64:	e766      	b.n	60001c34 <setOscModMixerB(int, float) [clone .constprop.168]+0xac>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001d66:	4b0c      	ldr	r3, [pc, #48]	; (60001d98 <setOscModMixerB(int, float) [clone .constprop.168]+0x210>)
60001d68:	e7d2      	b.n	60001d10 <setOscModMixerB(int, float) [clone .constprop.168]+0x188>
60001d6a:	bf00      	nop
60001d6c:	46fffe00 	.word	0x46fffe00
60001d70:	c6fffe00 	.word	0xc6fffe00
60001d74:	20009784 	.word	0x20009784
60001d78:	80010000 	.word	0x80010000
60001d7c:	200099dc 	.word	0x200099dc
60001d80:	2000f304 	.word	0x2000f304
60001d84:	2000fbc8 	.word	0x2000fbc8
60001d88:	2001049c 	.word	0x2001049c
60001d8c:	20010c94 	.word	0x20010c94
60001d90:	2000fc04 	.word	0x2000fc04
60001d94:	20011008 	.word	0x20011008
60001d98:	7fff0000 	.word	0x7fff0000

60001d9c <setOscModMixerA(int, float) [clone .constprop.170]>:
60001d9c:	eddf 7a78 	vldr	s15, [pc, #480]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
60001da0:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001da4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001da8:	f300 80aa 	bgt.w	60001f00 <setOscModMixerA(int, float) [clone .constprop.170]+0x164>
		else if (gain < -32767.0f) gain = -32767.0f;
60001dac:	ed9f 7a75 	vldr	s14, [pc, #468]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001db0:	eeb4 0ac7 	vcmpe.f32	s0, s14
60001db4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001db8:	f100 80b9 	bmi.w	60001f2e <setOscModMixerA(int, float) [clone .constprop.170]+0x192>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001dbc:	eef0 6a40 	vmov.f32	s13, s0
60001dc0:	4a71      	ldr	r2, [pc, #452]	; (60001f88 <setOscModMixerA(int, float) [clone .constprop.170]+0x1ec>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001dc2:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001dc6:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001dca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001dce:	ee16 3a90 	vmov	r3, s13
60001dd2:	edc2 6a09 	vstr	s13, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001dd6:	f300 80b3 	bgt.w	60001f40 <setOscModMixerA(int, float) [clone .constprop.170]+0x1a4>
60001dda:	eeb4 0ac7 	vcmpe.f32	s0, s14
60001dde:	4a6b      	ldr	r2, [pc, #428]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
60001de0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001de4:	bf48      	it	mi
60001de6:	4613      	movmi	r3, r2
60001de8:	eddf 7a65 	vldr	s15, [pc, #404]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001dec:	4a68      	ldr	r2, [pc, #416]	; (60001f90 <setOscModMixerA(int, float) [clone .constprop.170]+0x1f4>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001dee:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001df2:	6253      	str	r3, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001df4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001df8:	f300 8087 	bgt.w	60001f0a <setOscModMixerA(int, float) [clone .constprop.170]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
60001dfc:	eddf 7a61 	vldr	s15, [pc, #388]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001e00:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001e04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e08:	f100 808f 	bmi.w	60001f2a <setOscModMixerA(int, float) [clone .constprop.170]+0x18e>
60001e0c:	eef0 7a40 	vmov.f32	s15, s0
60001e10:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001e14:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e18:	eddf 7a59 	vldr	s15, [pc, #356]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001e1c:	4b5d      	ldr	r3, [pc, #372]	; (60001f94 <setOscModMixerA(int, float) [clone .constprop.170]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e1e:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001e22:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e28:	f300 808f 	bgt.w	60001f4a <setOscModMixerA(int, float) [clone .constprop.170]+0x1ae>
		else if (gain < -32767.0f) gain = -32767.0f;
60001e2c:	eddf 7a55 	vldr	s15, [pc, #340]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001e30:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001e34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e38:	f100 809d 	bmi.w	60001f76 <setOscModMixerA(int, float) [clone .constprop.170]+0x1da>
60001e3c:	eef0 7a40 	vmov.f32	s15, s0
60001e40:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001e44:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e48:	eddf 7a4d 	vldr	s15, [pc, #308]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001e4c:	4b52      	ldr	r3, [pc, #328]	; (60001f98 <setOscModMixerA(int, float) [clone .constprop.170]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e4e:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001e52:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e58:	dc5c      	bgt.n	60001f14 <setOscModMixerA(int, float) [clone .constprop.170]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
60001e5a:	eddf 7a4a 	vldr	s15, [pc, #296]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001e5e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001e62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e66:	f100 8084 	bmi.w	60001f72 <setOscModMixerA(int, float) [clone .constprop.170]+0x1d6>
60001e6a:	eef0 7a40 	vmov.f32	s15, s0
60001e6e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001e72:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e76:	eddf 7a42 	vldr	s15, [pc, #264]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001e7a:	4b48      	ldr	r3, [pc, #288]	; (60001f9c <setOscModMixerA(int, float) [clone .constprop.170]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e7c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001e80:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001e82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e86:	dc65      	bgt.n	60001f54 <setOscModMixerA(int, float) [clone .constprop.170]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
60001e88:	eddf 7a3e 	vldr	s15, [pc, #248]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001e8c:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001e94:	d46b      	bmi.n	60001f6e <setOscModMixerA(int, float) [clone .constprop.170]+0x1d2>
60001e96:	eef0 7a40 	vmov.f32	s15, s0
60001e9a:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001e9e:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001ea2:	eddf 7a37 	vldr	s15, [pc, #220]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001ea6:	4b3e      	ldr	r3, [pc, #248]	; (60001fa0 <setOscModMixerA(int, float) [clone .constprop.170]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001ea8:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001eac:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001eae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001eb2:	dc34      	bgt.n	60001f1e <setOscModMixerA(int, float) [clone .constprop.170]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
60001eb4:	eddf 7a33 	vldr	s15, [pc, #204]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001eb8:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001ebc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001ec0:	d453      	bmi.n	60001f6a <setOscModMixerA(int, float) [clone .constprop.170]+0x1ce>
60001ec2:	eef0 7a40 	vmov.f32	s15, s0
60001ec6:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001eca:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001ece:	eddf 7a2c 	vldr	s15, [pc, #176]	; 60001f80 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e4>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001ed2:	4b34      	ldr	r3, [pc, #208]	; (60001fa4 <setOscModMixerA(int, float) [clone .constprop.170]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001ed4:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001ed8:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001eda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001ede:	dc4c      	bgt.n	60001f7a <setOscModMixerA(int, float) [clone .constprop.170]+0x1de>
		else if (gain < -32767.0f) gain = -32767.0f;
60001ee0:	eddf 7a28 	vldr	s15, [pc, #160]	; 60001f84 <setOscModMixerA(int, float) [clone .constprop.170]+0x1e8>
60001ee4:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001ee8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001eec:	d439      	bmi.n	60001f62 <setOscModMixerA(int, float) [clone .constprop.170]+0x1c6>
60001eee:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001ef2:	4a2d      	ldr	r2, [pc, #180]	; (60001fa8 <setOscModMixerA(int, float) [clone .constprop.170]+0x20c>)
60001ef4:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60001ef8:	ee17 3a90 	vmov	r3, s15
60001efc:	6253      	str	r3, [r2, #36]	; 0x24
60001efe:	4770      	bx	lr
60001f00:	4b2a      	ldr	r3, [pc, #168]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f02:	4921      	ldr	r1, [pc, #132]	; (60001f88 <setOscModMixerA(int, float) [clone .constprop.170]+0x1ec>)
60001f04:	4a22      	ldr	r2, [pc, #136]	; (60001f90 <setOscModMixerA(int, float) [clone .constprop.170]+0x1f4>)
60001f06:	624b      	str	r3, [r1, #36]	; 0x24
60001f08:	6253      	str	r3, [r2, #36]	; 0x24
60001f0a:	4b28      	ldr	r3, [pc, #160]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f0c:	4921      	ldr	r1, [pc, #132]	; (60001f94 <setOscModMixerA(int, float) [clone .constprop.170]+0x1f8>)
60001f0e:	4a22      	ldr	r2, [pc, #136]	; (60001f98 <setOscModMixerA(int, float) [clone .constprop.170]+0x1fc>)
60001f10:	624b      	str	r3, [r1, #36]	; 0x24
60001f12:	6253      	str	r3, [r2, #36]	; 0x24
60001f14:	4b25      	ldr	r3, [pc, #148]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f16:	4921      	ldr	r1, [pc, #132]	; (60001f9c <setOscModMixerA(int, float) [clone .constprop.170]+0x200>)
60001f18:	4a21      	ldr	r2, [pc, #132]	; (60001fa0 <setOscModMixerA(int, float) [clone .constprop.170]+0x204>)
60001f1a:	624b      	str	r3, [r1, #36]	; 0x24
60001f1c:	6253      	str	r3, [r2, #36]	; 0x24
60001f1e:	4a21      	ldr	r2, [pc, #132]	; (60001fa4 <setOscModMixerA(int, float) [clone .constprop.170]+0x208>)
60001f20:	4b22      	ldr	r3, [pc, #136]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f22:	6253      	str	r3, [r2, #36]	; 0x24
60001f24:	4a20      	ldr	r2, [pc, #128]	; (60001fa8 <setOscModMixerA(int, float) [clone .constprop.170]+0x20c>)
60001f26:	6253      	str	r3, [r2, #36]	; 0x24
60001f28:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001f2a:	4a18      	ldr	r2, [pc, #96]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
60001f2c:	e774      	b.n	60001e18 <setOscModMixerA(int, float) [clone .constprop.170]+0x7c>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001f2e:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001f32:	4a15      	ldr	r2, [pc, #84]	; (60001f88 <setOscModMixerA(int, float) [clone .constprop.170]+0x1ec>)
60001f34:	4b15      	ldr	r3, [pc, #84]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001f36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001f3a:	6253      	str	r3, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001f3c:	f77f af54 	ble.w	60001de8 <setOscModMixerA(int, float) [clone .constprop.170]+0x4c>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001f40:	4b1a      	ldr	r3, [pc, #104]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f42:	4913      	ldr	r1, [pc, #76]	; (60001f90 <setOscModMixerA(int, float) [clone .constprop.170]+0x1f4>)
60001f44:	4a13      	ldr	r2, [pc, #76]	; (60001f94 <setOscModMixerA(int, float) [clone .constprop.170]+0x1f8>)
60001f46:	624b      	str	r3, [r1, #36]	; 0x24
60001f48:	6253      	str	r3, [r2, #36]	; 0x24
60001f4a:	4b18      	ldr	r3, [pc, #96]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f4c:	4912      	ldr	r1, [pc, #72]	; (60001f98 <setOscModMixerA(int, float) [clone .constprop.170]+0x1fc>)
60001f4e:	4a13      	ldr	r2, [pc, #76]	; (60001f9c <setOscModMixerA(int, float) [clone .constprop.170]+0x200>)
60001f50:	624b      	str	r3, [r1, #36]	; 0x24
60001f52:	6253      	str	r3, [r2, #36]	; 0x24
60001f54:	4a15      	ldr	r2, [pc, #84]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f56:	4b12      	ldr	r3, [pc, #72]	; (60001fa0 <setOscModMixerA(int, float) [clone .constprop.170]+0x204>)
60001f58:	4912      	ldr	r1, [pc, #72]	; (60001fa4 <setOscModMixerA(int, float) [clone .constprop.170]+0x208>)
60001f5a:	625a      	str	r2, [r3, #36]	; 0x24
60001f5c:	4613      	mov	r3, r2
60001f5e:	624a      	str	r2, [r1, #36]	; 0x24
60001f60:	e7e0      	b.n	60001f24 <setOscModMixerA(int, float) [clone .constprop.170]+0x188>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001f62:	4b0a      	ldr	r3, [pc, #40]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001f64:	4a10      	ldr	r2, [pc, #64]	; (60001fa8 <setOscModMixerA(int, float) [clone .constprop.170]+0x20c>)
60001f66:	6253      	str	r3, [r2, #36]	; 0x24
60001f68:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60001f6a:	4a08      	ldr	r2, [pc, #32]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
60001f6c:	e7af      	b.n	60001ece <setOscModMixerA(int, float) [clone .constprop.170]+0x132>
60001f6e:	4a07      	ldr	r2, [pc, #28]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
60001f70:	e797      	b.n	60001ea2 <setOscModMixerA(int, float) [clone .constprop.170]+0x106>
60001f72:	4a06      	ldr	r2, [pc, #24]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
60001f74:	e77f      	b.n	60001e76 <setOscModMixerA(int, float) [clone .constprop.170]+0xda>
60001f76:	4a05      	ldr	r2, [pc, #20]	; (60001f8c <setOscModMixerA(int, float) [clone .constprop.170]+0x1f0>)
60001f78:	e766      	b.n	60001e48 <setOscModMixerA(int, float) [clone .constprop.170]+0xac>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001f7a:	4b0c      	ldr	r3, [pc, #48]	; (60001fac <setOscModMixerA(int, float) [clone .constprop.170]+0x210>)
60001f7c:	e7d2      	b.n	60001f24 <setOscModMixerA(int, float) [clone .constprop.170]+0x188>
60001f7e:	bf00      	nop
60001f80:	46fffe00 	.word	0x46fffe00
60001f84:	c6fffe00 	.word	0xc6fffe00
60001f88:	2000974c 	.word	0x2000974c
60001f8c:	80010000 	.word	0x80010000
60001f90:	200099a4 	.word	0x200099a4
60001f94:	2000f2cc 	.word	0x2000f2cc
60001f98:	2000fb90 	.word	0x2000fb90
60001f9c:	20010464 	.word	0x20010464
60001fa0:	20010c5c 	.word	0x20010c5c
60001fa4:	20010dbc 	.word	0x20010dbc
60001fa8:	20010fd0 	.word	0x20010fd0
60001fac:	7fff0000 	.word	0x7fff0000

60001fb0 <setWaveformMixerLevel(int, float) [clone .constprop.172]>:
	filterMixer7.gain(1, BP);
	filterMixer7.gain(2, HP);
	filterMixer8.gain(0, LP);
	filterMixer8.gain(1, BP);
	filterMixer8.gain(2, HP);
	showCurrentParameterPage("Filter Type", filterStr);
60001fb0:	4b7a      	ldr	r3, [pc, #488]	; (6000219c <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1ec>)
60001fb2:	ed9f 7a7b 	vldr	s14, [pc, #492]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
60001fb6:	edd3 7a00 	vldr	s15, [r3]
60001fba:	ee20 0a27 	vmul.f32	s0, s0, s15
60001fbe:	eeb4 0ac7 	vcmpe.f32	s0, s14
60001fc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001fc6:	f300 80aa 	bgt.w	6000211e <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
60001fca:	eddf 7a76 	vldr	s15, [pc, #472]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
60001fce:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001fd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60001fd6:	f100 80b9 	bmi.w	6000214c <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x19c>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001fda:	eef0 6a40 	vmov.f32	s13, s0
60001fde:	4a72      	ldr	r2, [pc, #456]	; (600021a8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001fe0:	eeb4 0ac7 	vcmpe.f32	s0, s14
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001fe4:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001fe8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60001fec:	ee16 3a90 	vmov	r3, s13
60001ff0:	edc2 6a06 	vstr	s13, [r2, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60001ff4:	f300 80b3 	bgt.w	6000215e <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1ae>
60001ff8:	eeb4 0ae7 	vcmpe.f32	s0, s15
60001ffc:	4a6b      	ldr	r2, [pc, #428]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
60001ffe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002002:	bf48      	it	mi
60002004:	4613      	movmi	r3, r2
60002006:	eddf 7a66 	vldr	s15, [pc, #408]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000200a:	4a69      	ldr	r2, [pc, #420]	; (600021b0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000200c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002010:	6193      	str	r3, [r2, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002016:	f300 8087 	bgt.w	60002128 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
6000201a:	eddf 7a62 	vldr	s15, [pc, #392]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
6000201e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002026:	f100 808f 	bmi.w	60002148 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x198>
6000202a:	eef0 7a40 	vmov.f32	s15, s0
6000202e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002032:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002036:	eddf 7a5a 	vldr	s15, [pc, #360]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000203a:	4b5e      	ldr	r3, [pc, #376]	; (600021b4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000203c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002040:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002042:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002046:	f300 808f 	bgt.w	60002168 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
6000204a:	eddf 7a56 	vldr	s15, [pc, #344]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
6000204e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002052:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002056:	f100 809d 	bmi.w	60002194 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1e4>
6000205a:	eef0 7a40 	vmov.f32	s15, s0
6000205e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002062:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002066:	eddf 7a4e 	vldr	s15, [pc, #312]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000206a:	4b53      	ldr	r3, [pc, #332]	; (600021b8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000206c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002070:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002072:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002076:	dc5c      	bgt.n	60002132 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
60002078:	eddf 7a4a 	vldr	s15, [pc, #296]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
6000207c:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002080:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002084:	f100 8084 	bmi.w	60002190 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1e0>
60002088:	eef0 7a40 	vmov.f32	s15, s0
6000208c:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002090:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002094:	eddf 7a42 	vldr	s15, [pc, #264]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002098:	4b48      	ldr	r3, [pc, #288]	; (600021bc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x20c>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000209a:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000209e:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600020a4:	dc65      	bgt.n	60002172 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1c2>
		else if (gain < -32767.0f) gain = -32767.0f;
600020a6:	eddf 7a3f 	vldr	s15, [pc, #252]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
600020aa:	eeb4 0ae7 	vcmpe.f32	s0, s15
600020ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600020b2:	d46b      	bmi.n	6000218c <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1dc>
600020b4:	eef0 7a40 	vmov.f32	s15, s0
600020b8:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600020bc:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020c0:	eddf 7a37 	vldr	s15, [pc, #220]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600020c4:	4b3e      	ldr	r3, [pc, #248]	; (600021c0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x210>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020c6:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600020ca:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600020d0:	dc34      	bgt.n	6000213c <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x18c>
		else if (gain < -32767.0f) gain = -32767.0f;
600020d2:	eddf 7a34 	vldr	s15, [pc, #208]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
600020d6:	eeb4 0ae7 	vcmpe.f32	s0, s15
600020da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600020de:	d453      	bmi.n	60002188 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1d8>
600020e0:	eef0 7a40 	vmov.f32	s15, s0
600020e4:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600020e8:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020ec:	eddf 7a2c 	vldr	s15, [pc, #176]	; 600021a0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600020f0:	4b34      	ldr	r3, [pc, #208]	; (600021c4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x214>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020f2:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600020f6:	619a      	str	r2, [r3, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600020f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600020fc:	dc4c      	bgt.n	60002198 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1e8>
		else if (gain < -32767.0f) gain = -32767.0f;
600020fe:	eddf 7a29 	vldr	s15, [pc, #164]	; 600021a4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f4>
60002102:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002106:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000210a:	d439      	bmi.n	60002180 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1d0>
6000210c:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002110:	4a2d      	ldr	r2, [pc, #180]	; (600021c8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x218>)
60002112:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002116:	ee17 3a90 	vmov	r3, s15
6000211a:	6193      	str	r3, [r2, #24]
6000211c:	4770      	bx	lr
6000211e:	4b2b      	ldr	r3, [pc, #172]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
60002120:	4921      	ldr	r1, [pc, #132]	; (600021a8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f8>)
60002122:	4a23      	ldr	r2, [pc, #140]	; (600021b0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x200>)
60002124:	618b      	str	r3, [r1, #24]
60002126:	6193      	str	r3, [r2, #24]
60002128:	4b28      	ldr	r3, [pc, #160]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
6000212a:	4922      	ldr	r1, [pc, #136]	; (600021b4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x204>)
6000212c:	4a22      	ldr	r2, [pc, #136]	; (600021b8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x208>)
6000212e:	618b      	str	r3, [r1, #24]
60002130:	6193      	str	r3, [r2, #24]
60002132:	4b26      	ldr	r3, [pc, #152]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
60002134:	4921      	ldr	r1, [pc, #132]	; (600021bc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x20c>)
60002136:	4a22      	ldr	r2, [pc, #136]	; (600021c0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x210>)
60002138:	618b      	str	r3, [r1, #24]
6000213a:	6193      	str	r3, [r2, #24]
6000213c:	4a21      	ldr	r2, [pc, #132]	; (600021c4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x214>)
6000213e:	4b23      	ldr	r3, [pc, #140]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
60002140:	6193      	str	r3, [r2, #24]
60002142:	4a21      	ldr	r2, [pc, #132]	; (600021c8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x218>)
60002144:	6193      	str	r3, [r2, #24]
60002146:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60002148:	4a18      	ldr	r2, [pc, #96]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
6000214a:	e774      	b.n	60002036 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x86>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000214c:	eeb4 0ac7 	vcmpe.f32	s0, s14
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002150:	4a15      	ldr	r2, [pc, #84]	; (600021a8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1f8>)
60002152:	4b16      	ldr	r3, [pc, #88]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002154:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002158:	6193      	str	r3, [r2, #24]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000215a:	f77f af54 	ble.w	60002006 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x56>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000215e:	4b1b      	ldr	r3, [pc, #108]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
60002160:	4913      	ldr	r1, [pc, #76]	; (600021b0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x200>)
60002162:	4a14      	ldr	r2, [pc, #80]	; (600021b4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x204>)
60002164:	618b      	str	r3, [r1, #24]
60002166:	6193      	str	r3, [r2, #24]
60002168:	4b18      	ldr	r3, [pc, #96]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
6000216a:	4913      	ldr	r1, [pc, #76]	; (600021b8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x208>)
6000216c:	4a13      	ldr	r2, [pc, #76]	; (600021bc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x20c>)
6000216e:	618b      	str	r3, [r1, #24]
60002170:	6193      	str	r3, [r2, #24]
60002172:	4a16      	ldr	r2, [pc, #88]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
60002174:	4b12      	ldr	r3, [pc, #72]	; (600021c0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x210>)
60002176:	4913      	ldr	r1, [pc, #76]	; (600021c4 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x214>)
60002178:	619a      	str	r2, [r3, #24]
6000217a:	4613      	mov	r3, r2
6000217c:	618a      	str	r2, [r1, #24]
6000217e:	e7e0      	b.n	60002142 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x192>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60002180:	4b0a      	ldr	r3, [pc, #40]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002182:	4a11      	ldr	r2, [pc, #68]	; (600021c8 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x218>)
60002184:	6193      	str	r3, [r2, #24]
60002186:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60002188:	4a08      	ldr	r2, [pc, #32]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
6000218a:	e7af      	b.n	600020ec <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x13c>
6000218c:	4a07      	ldr	r2, [pc, #28]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
6000218e:	e797      	b.n	600020c0 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x110>
60002190:	4a06      	ldr	r2, [pc, #24]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
60002192:	e77f      	b.n	60002094 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0xe4>
60002194:	4a05      	ldr	r2, [pc, #20]	; (600021ac <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x1fc>)
60002196:	e766      	b.n	60002066 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0xb6>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002198:	4b0c      	ldr	r3, [pc, #48]	; (600021cc <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x21c>)
6000219a:	e7d2      	b.n	60002142 <setWaveformMixerLevel(int, float) [clone .constprop.172]+0x192>
6000219c:	20004e34 	.word	0x20004e34
600021a0:	46fffe00 	.word	0x46fffe00
600021a4:	c6fffe00 	.word	0xc6fffe00
600021a8:	20013050 	.word	0x20013050
600021ac:	80010000 	.word	0x80010000
600021b0:	20013088 	.word	0x20013088
600021b4:	200130c0 	.word	0x200130c0
600021b8:	200130f8 	.word	0x200130f8
600021bc:	20013130 	.word	0x20013130
600021c0:	20013168 	.word	0x20013168
600021c4:	200131a0 	.word	0x200131a0
600021c8:	200131d8 	.word	0x200131d8
600021cc:	7fff0000 	.word	0x7fff0000

600021d0 <setWaveformMixerLevel(int, float) [clone .constprop.173]>:
600021d0:	4b7a      	ldr	r3, [pc, #488]	; (600023bc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1ec>)
600021d2:	ed9f 7a7b 	vldr	s14, [pc, #492]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
600021d6:	edd3 7a00 	vldr	s15, [r3]
600021da:	ee20 0a27 	vmul.f32	s0, s0, s15
600021de:	eeb4 0ac7 	vcmpe.f32	s0, s14
600021e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600021e6:	f300 80aa 	bgt.w	6000233e <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
600021ea:	eddf 7a76 	vldr	s15, [pc, #472]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
600021ee:	eeb4 0ae7 	vcmpe.f32	s0, s15
600021f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600021f6:	f100 80b9 	bmi.w	6000236c <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x19c>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600021fa:	eef0 6a40 	vmov.f32	s13, s0
600021fe:	4a72      	ldr	r2, [pc, #456]	; (600023c8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002200:	eeb4 0ac7 	vcmpe.f32	s0, s14
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002204:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002208:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000220c:	ee16 3a90 	vmov	r3, s13
60002210:	edc2 6a07 	vstr	s13, [r2, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002214:	f300 80b3 	bgt.w	6000237e <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1ae>
60002218:	eeb4 0ae7 	vcmpe.f32	s0, s15
6000221c:	4a6b      	ldr	r2, [pc, #428]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
6000221e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002222:	bf48      	it	mi
60002224:	4613      	movmi	r3, r2
60002226:	eddf 7a66 	vldr	s15, [pc, #408]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000222a:	4a69      	ldr	r2, [pc, #420]	; (600023d0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000222c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002230:	61d3      	str	r3, [r2, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002232:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002236:	f300 8087 	bgt.w	60002348 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
6000223a:	eddf 7a62 	vldr	s15, [pc, #392]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
6000223e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002242:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002246:	f100 808f 	bmi.w	60002368 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x198>
6000224a:	eef0 7a40 	vmov.f32	s15, s0
6000224e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002252:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002256:	eddf 7a5a 	vldr	s15, [pc, #360]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000225a:	4b5e      	ldr	r3, [pc, #376]	; (600023d4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000225c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002260:	61da      	str	r2, [r3, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002262:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002266:	f300 808f 	bgt.w	60002388 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
6000226a:	eddf 7a56 	vldr	s15, [pc, #344]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
6000226e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002272:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002276:	f100 809d 	bmi.w	600023b4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1e4>
6000227a:	eef0 7a40 	vmov.f32	s15, s0
6000227e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002282:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002286:	eddf 7a4e 	vldr	s15, [pc, #312]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000228a:	4b53      	ldr	r3, [pc, #332]	; (600023d8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000228c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002290:	61da      	str	r2, [r3, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002292:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002296:	dc5c      	bgt.n	60002352 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
60002298:	eddf 7a4a 	vldr	s15, [pc, #296]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
6000229c:	eeb4 0ae7 	vcmpe.f32	s0, s15
600022a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600022a4:	f100 8084 	bmi.w	600023b0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1e0>
600022a8:	eef0 7a40 	vmov.f32	s15, s0
600022ac:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600022b0:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600022b4:	eddf 7a42 	vldr	s15, [pc, #264]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600022b8:	4b48      	ldr	r3, [pc, #288]	; (600023dc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x20c>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600022ba:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600022be:	61da      	str	r2, [r3, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600022c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600022c4:	dc65      	bgt.n	60002392 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1c2>
		else if (gain < -32767.0f) gain = -32767.0f;
600022c6:	eddf 7a3f 	vldr	s15, [pc, #252]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
600022ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
600022ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600022d2:	d46b      	bmi.n	600023ac <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1dc>
600022d4:	eef0 7a40 	vmov.f32	s15, s0
600022d8:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600022dc:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600022e0:	eddf 7a37 	vldr	s15, [pc, #220]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600022e4:	4b3e      	ldr	r3, [pc, #248]	; (600023e0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x210>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600022e6:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600022ea:	61da      	str	r2, [r3, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600022ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600022f0:	dc34      	bgt.n	6000235c <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x18c>
		else if (gain < -32767.0f) gain = -32767.0f;
600022f2:	eddf 7a34 	vldr	s15, [pc, #208]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
600022f6:	eeb4 0ae7 	vcmpe.f32	s0, s15
600022fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600022fe:	d453      	bmi.n	600023a8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1d8>
60002300:	eef0 7a40 	vmov.f32	s15, s0
60002304:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002308:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000230c:	eddf 7a2c 	vldr	s15, [pc, #176]	; 600023c0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002310:	4b34      	ldr	r3, [pc, #208]	; (600023e4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x214>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002312:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002316:	61da      	str	r2, [r3, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002318:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000231c:	dc4c      	bgt.n	600023b8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1e8>
		else if (gain < -32767.0f) gain = -32767.0f;
6000231e:	eddf 7a29 	vldr	s15, [pc, #164]	; 600023c4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f4>
60002322:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002326:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000232a:	d439      	bmi.n	600023a0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1d0>
6000232c:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002330:	4a2d      	ldr	r2, [pc, #180]	; (600023e8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x218>)
60002332:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002336:	ee17 3a90 	vmov	r3, s15
6000233a:	61d3      	str	r3, [r2, #28]
6000233c:	4770      	bx	lr
6000233e:	4b2b      	ldr	r3, [pc, #172]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
60002340:	4921      	ldr	r1, [pc, #132]	; (600023c8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f8>)
60002342:	4a23      	ldr	r2, [pc, #140]	; (600023d0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x200>)
60002344:	61cb      	str	r3, [r1, #28]
60002346:	61d3      	str	r3, [r2, #28]
60002348:	4b28      	ldr	r3, [pc, #160]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
6000234a:	4922      	ldr	r1, [pc, #136]	; (600023d4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x204>)
6000234c:	4a22      	ldr	r2, [pc, #136]	; (600023d8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x208>)
6000234e:	61cb      	str	r3, [r1, #28]
60002350:	61d3      	str	r3, [r2, #28]
60002352:	4b26      	ldr	r3, [pc, #152]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
60002354:	4921      	ldr	r1, [pc, #132]	; (600023dc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x20c>)
60002356:	4a22      	ldr	r2, [pc, #136]	; (600023e0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x210>)
60002358:	61cb      	str	r3, [r1, #28]
6000235a:	61d3      	str	r3, [r2, #28]
6000235c:	4a21      	ldr	r2, [pc, #132]	; (600023e4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x214>)
6000235e:	4b23      	ldr	r3, [pc, #140]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
60002360:	61d3      	str	r3, [r2, #28]
60002362:	4a21      	ldr	r2, [pc, #132]	; (600023e8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x218>)
60002364:	61d3      	str	r3, [r2, #28]
60002366:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60002368:	4a18      	ldr	r2, [pc, #96]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
6000236a:	e774      	b.n	60002256 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x86>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000236c:	eeb4 0ac7 	vcmpe.f32	s0, s14
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002370:	4a15      	ldr	r2, [pc, #84]	; (600023c8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1f8>)
60002372:	4b16      	ldr	r3, [pc, #88]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002374:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002378:	61d3      	str	r3, [r2, #28]
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000237a:	f77f af54 	ble.w	60002226 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x56>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000237e:	4b1b      	ldr	r3, [pc, #108]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
60002380:	4913      	ldr	r1, [pc, #76]	; (600023d0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x200>)
60002382:	4a14      	ldr	r2, [pc, #80]	; (600023d4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x204>)
60002384:	61cb      	str	r3, [r1, #28]
60002386:	61d3      	str	r3, [r2, #28]
60002388:	4b18      	ldr	r3, [pc, #96]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
6000238a:	4913      	ldr	r1, [pc, #76]	; (600023d8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x208>)
6000238c:	4a13      	ldr	r2, [pc, #76]	; (600023dc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x20c>)
6000238e:	61cb      	str	r3, [r1, #28]
60002390:	61d3      	str	r3, [r2, #28]
60002392:	4a16      	ldr	r2, [pc, #88]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
60002394:	4b12      	ldr	r3, [pc, #72]	; (600023e0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x210>)
60002396:	4913      	ldr	r1, [pc, #76]	; (600023e4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x214>)
60002398:	61da      	str	r2, [r3, #28]
6000239a:	4613      	mov	r3, r2
6000239c:	61ca      	str	r2, [r1, #28]
6000239e:	e7e0      	b.n	60002362 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x192>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
600023a0:	4b0a      	ldr	r3, [pc, #40]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600023a2:	4a11      	ldr	r2, [pc, #68]	; (600023e8 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x218>)
600023a4:	61d3      	str	r3, [r2, #28]
600023a6:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
600023a8:	4a08      	ldr	r2, [pc, #32]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
600023aa:	e7af      	b.n	6000230c <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x13c>
600023ac:	4a07      	ldr	r2, [pc, #28]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
600023ae:	e797      	b.n	600022e0 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x110>
600023b0:	4a06      	ldr	r2, [pc, #24]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
600023b2:	e77f      	b.n	600022b4 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0xe4>
600023b4:	4a05      	ldr	r2, [pc, #20]	; (600023cc <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x1fc>)
600023b6:	e766      	b.n	60002286 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0xb6>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600023b8:	4b0c      	ldr	r3, [pc, #48]	; (600023ec <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x21c>)
600023ba:	e7d2      	b.n	60002362 <setWaveformMixerLevel(int, float) [clone .constprop.173]+0x192>
600023bc:	20004e34 	.word	0x20004e34
600023c0:	46fffe00 	.word	0x46fffe00
600023c4:	c6fffe00 	.word	0xc6fffe00
600023c8:	20013050 	.word	0x20013050
600023cc:	80010000 	.word	0x80010000
600023d0:	20013088 	.word	0x20013088
600023d4:	200130c0 	.word	0x200130c0
600023d8:	200130f8 	.word	0x200130f8
600023dc:	20013130 	.word	0x20013130
600023e0:	20013168 	.word	0x20013168
600023e4:	200131a0 	.word	0x200131a0
600023e8:	200131d8 	.word	0x200131d8
600023ec:	7fff0000 	.word	0x7fff0000

600023f0 <setWaveformMixerLevel(int, float) [clone .constprop.174]>:
600023f0:	4b7a      	ldr	r3, [pc, #488]	; (600025dc <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1ec>)
600023f2:	ed9f 7a7b 	vldr	s14, [pc, #492]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
600023f6:	edd3 7a00 	vldr	s15, [r3]
600023fa:	ee20 0a27 	vmul.f32	s0, s0, s15
600023fe:	eeb4 0ac7 	vcmpe.f32	s0, s14
60002402:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002406:	f300 80aa 	bgt.w	6000255e <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x16e>
		else if (gain < -32767.0f) gain = -32767.0f;
6000240a:	eddf 7a76 	vldr	s15, [pc, #472]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
6000240e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002412:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002416:	f100 80b9 	bmi.w	6000258c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x19c>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000241a:	eef0 6a40 	vmov.f32	s13, s0
6000241e:	4a72      	ldr	r2, [pc, #456]	; (600025e8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f8>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002420:	eeb4 0ac7 	vcmpe.f32	s0, s14
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002424:	eefe 6ac8 	vcvt.s32.f32	s13, s13, #16
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002428:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000242c:	ee16 3a90 	vmov	r3, s13
60002430:	edc2 6a09 	vstr	s13, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002434:	f300 80b3 	bgt.w	6000259e <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1ae>
60002438:	eeb4 0ae7 	vcmpe.f32	s0, s15
6000243c:	4a6b      	ldr	r2, [pc, #428]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
6000243e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002442:	bf48      	it	mi
60002444:	4613      	movmi	r3, r2
60002446:	eddf 7a66 	vldr	s15, [pc, #408]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000244a:	4a69      	ldr	r2, [pc, #420]	; (600025f0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x200>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000244c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002450:	6253      	str	r3, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002452:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002456:	f300 8087 	bgt.w	60002568 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x178>
		else if (gain < -32767.0f) gain = -32767.0f;
6000245a:	eddf 7a62 	vldr	s15, [pc, #392]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
6000245e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002462:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002466:	f100 808f 	bmi.w	60002588 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x198>
6000246a:	eef0 7a40 	vmov.f32	s15, s0
6000246e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002472:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002476:	eddf 7a5a 	vldr	s15, [pc, #360]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000247a:	4b5e      	ldr	r3, [pc, #376]	; (600025f4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x204>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000247c:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002480:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002482:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002486:	f300 808f 	bgt.w	600025a8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1b8>
		else if (gain < -32767.0f) gain = -32767.0f;
6000248a:	eddf 7a56 	vldr	s15, [pc, #344]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
6000248e:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002492:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002496:	f100 809d 	bmi.w	600025d4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1e4>
6000249a:	eef0 7a40 	vmov.f32	s15, s0
6000249e:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600024a2:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600024a6:	eddf 7a4e 	vldr	s15, [pc, #312]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600024aa:	4b53      	ldr	r3, [pc, #332]	; (600025f8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x208>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600024ac:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600024b0:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600024b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600024b6:	dc5c      	bgt.n	60002572 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x182>
		else if (gain < -32767.0f) gain = -32767.0f;
600024b8:	eddf 7a4a 	vldr	s15, [pc, #296]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
600024bc:	eeb4 0ae7 	vcmpe.f32	s0, s15
600024c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600024c4:	f100 8084 	bmi.w	600025d0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1e0>
600024c8:	eef0 7a40 	vmov.f32	s15, s0
600024cc:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600024d0:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600024d4:	eddf 7a42 	vldr	s15, [pc, #264]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600024d8:	4b48      	ldr	r3, [pc, #288]	; (600025fc <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x20c>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600024da:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600024de:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600024e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600024e4:	dc65      	bgt.n	600025b2 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1c2>
		else if (gain < -32767.0f) gain = -32767.0f;
600024e6:	eddf 7a3f 	vldr	s15, [pc, #252]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
600024ea:	eeb4 0ae7 	vcmpe.f32	s0, s15
600024ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600024f2:	d46b      	bmi.n	600025cc <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1dc>
600024f4:	eef0 7a40 	vmov.f32	s15, s0
600024f8:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
600024fc:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002500:	eddf 7a37 	vldr	s15, [pc, #220]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002504:	4b3e      	ldr	r3, [pc, #248]	; (60002600 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x210>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002506:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000250a:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000250c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002510:	dc34      	bgt.n	6000257c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x18c>
		else if (gain < -32767.0f) gain = -32767.0f;
60002512:	eddf 7a34 	vldr	s15, [pc, #208]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
60002516:	eeb4 0ae7 	vcmpe.f32	s0, s15
6000251a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000251e:	d453      	bmi.n	600025c8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1d8>
60002520:	eef0 7a40 	vmov.f32	s15, s0
60002524:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002528:	ee17 2a90 	vmov	r2, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000252c:	eddf 7a2c 	vldr	s15, [pc, #176]	; 600025e0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f0>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002530:	4b34      	ldr	r3, [pc, #208]	; (60002604 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x214>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002532:	eeb4 0ae7 	vcmpe.f32	s0, s15
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002536:	625a      	str	r2, [r3, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002538:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000253c:	dc4c      	bgt.n	600025d8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1e8>
		else if (gain < -32767.0f) gain = -32767.0f;
6000253e:	eddf 7a29 	vldr	s15, [pc, #164]	; 600025e4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f4>
60002542:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002546:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000254a:	d439      	bmi.n	600025c0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1d0>
6000254c:	eef0 7a40 	vmov.f32	s15, s0
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002550:	4a2d      	ldr	r2, [pc, #180]	; (60002608 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x218>)
60002552:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
60002556:	ee17 3a90 	vmov	r3, s15
6000255a:	6253      	str	r3, [r2, #36]	; 0x24
6000255c:	4770      	bx	lr
6000255e:	4b2b      	ldr	r3, [pc, #172]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
60002560:	4921      	ldr	r1, [pc, #132]	; (600025e8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f8>)
60002562:	4a23      	ldr	r2, [pc, #140]	; (600025f0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x200>)
60002564:	624b      	str	r3, [r1, #36]	; 0x24
60002566:	6253      	str	r3, [r2, #36]	; 0x24
60002568:	4b28      	ldr	r3, [pc, #160]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
6000256a:	4922      	ldr	r1, [pc, #136]	; (600025f4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x204>)
6000256c:	4a22      	ldr	r2, [pc, #136]	; (600025f8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x208>)
6000256e:	624b      	str	r3, [r1, #36]	; 0x24
60002570:	6253      	str	r3, [r2, #36]	; 0x24
60002572:	4b26      	ldr	r3, [pc, #152]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
60002574:	4921      	ldr	r1, [pc, #132]	; (600025fc <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x20c>)
60002576:	4a22      	ldr	r2, [pc, #136]	; (60002600 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x210>)
60002578:	624b      	str	r3, [r1, #36]	; 0x24
6000257a:	6253      	str	r3, [r2, #36]	; 0x24
6000257c:	4a21      	ldr	r2, [pc, #132]	; (60002604 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x214>)
6000257e:	4b23      	ldr	r3, [pc, #140]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
60002580:	6253      	str	r3, [r2, #36]	; 0x24
60002582:	4a21      	ldr	r2, [pc, #132]	; (60002608 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x218>)
60002584:	6253      	str	r3, [r2, #36]	; 0x24
60002586:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
60002588:	4a18      	ldr	r2, [pc, #96]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
6000258a:	e774      	b.n	60002476 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x86>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000258c:	eeb4 0ac7 	vcmpe.f32	s0, s14
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002590:	4a15      	ldr	r2, [pc, #84]	; (600025e8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1f8>)
60002592:	4b16      	ldr	r3, [pc, #88]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002594:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002598:	6253      	str	r3, [r2, #36]	; 0x24
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
6000259a:	f77f af54 	ble.w	60002446 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x56>
		else if (gain < -32767.0f) gain = -32767.0f;
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
6000259e:	4b1b      	ldr	r3, [pc, #108]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
600025a0:	4913      	ldr	r1, [pc, #76]	; (600025f0 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x200>)
600025a2:	4a14      	ldr	r2, [pc, #80]	; (600025f4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x204>)
600025a4:	624b      	str	r3, [r1, #36]	; 0x24
600025a6:	6253      	str	r3, [r2, #36]	; 0x24
600025a8:	4b18      	ldr	r3, [pc, #96]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
600025aa:	4913      	ldr	r1, [pc, #76]	; (600025f8 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x208>)
600025ac:	4a13      	ldr	r2, [pc, #76]	; (600025fc <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x20c>)
600025ae:	624b      	str	r3, [r1, #36]	; 0x24
600025b0:	6253      	str	r3, [r2, #36]	; 0x24
600025b2:	4a16      	ldr	r2, [pc, #88]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
600025b4:	4b12      	ldr	r3, [pc, #72]	; (60002600 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x210>)
600025b6:	4913      	ldr	r1, [pc, #76]	; (60002604 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x214>)
600025b8:	625a      	str	r2, [r3, #36]	; 0x24
600025ba:	4613      	mov	r3, r2
600025bc:	624a      	str	r2, [r1, #36]	; 0x24
600025be:	e7e0      	b.n	60002582 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x192>
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
600025c0:	4b0a      	ldr	r3, [pc, #40]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
600025c2:	4a11      	ldr	r2, [pc, #68]	; (60002608 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x218>)
600025c4:	6253      	str	r3, [r2, #36]	; 0x24
600025c6:	4770      	bx	lr
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
		else if (gain < -32767.0f) gain = -32767.0f;
600025c8:	4a08      	ldr	r2, [pc, #32]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
600025ca:	e7af      	b.n	6000252c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x13c>
600025cc:	4a07      	ldr	r2, [pc, #28]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
600025ce:	e797      	b.n	60002500 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x110>
600025d0:	4a06      	ldr	r2, [pc, #24]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
600025d2:	e77f      	b.n	600024d4 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0xe4>
600025d4:	4a05      	ldr	r2, [pc, #20]	; (600025ec <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x1fc>)
600025d6:	e766      	b.n	600024a6 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0xb6>
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
600025d8:	4b0c      	ldr	r3, [pc, #48]	; (6000260c <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x21c>)
600025da:	e7d2      	b.n	60002582 <setWaveformMixerLevel(int, float) [clone .constprop.174]+0x192>
600025dc:	20004e34 	.word	0x20004e34
600025e0:	46fffe00 	.word	0x46fffe00
600025e4:	c6fffe00 	.word	0xc6fffe00
600025e8:	20013050 	.word	0x20013050
600025ec:	80010000 	.word	0x80010000
600025f0:	20013088 	.word	0x20013088
600025f4:	200130c0 	.word	0x200130c0
600025f8:	200130f8 	.word	0x200130f8
600025fc:	20013130 	.word	0x20013130
60002600:	20013168 	.word	0x20013168
60002604:	200131a0 	.word	0x200131a0
60002608:	200131d8 	.word	0x200131d8
6000260c:	7fff0000 	.word	0x7fff0000

60002610 <setPatchesOrdering(int) [clone .part.92]>:
    }
  }
  deletePatch(String(patches.size() + 1).c_str()); //Delete final patch which is duplicate of penultimate patch
}

FLASHMEM void setPatchesOrdering(int no) {
60002610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60002614:	4d34      	ldr	r5, [pc, #208]	; (600026e8 <setPatchesOrdering(int) [clone .part.92]+0xd8>)
60002616:	b08b      	sub	sp, #44	; 0x2c
60002618:	4680      	mov	r8, r0
	}
}

template<typename T, size_t S, typename IT>
bool CircularBuffer<T,S,IT>::push(T value) {
	if (++tail == buffer + capacity) {
6000261a:	1d2f      	adds	r7, r5, #4
6000261c:	f5a5 49a0 	sub.w	r9, r5, #20480	; 0x5000
60002620:	462e      	mov	r6, r5
	}
}

template<typename T, size_t S, typename IT>
T CircularBuffer<T,S,IT>::shift() {
	if (count == 0) return *head;
60002622:	f105 0408 	add.w	r4, r5, #8
	}
}

template<typename T, size_t S, typename IT>
bool CircularBuffer<T,S,IT>::push(T value) {
	if (++tail == buffer + capacity) {
60002626:	46ba      	mov	sl, r7
60002628:	e032      	b.n	60002690 <setPatchesOrdering(int) [clone .part.92]+0x80>
}

template<typename T, size_t S, typename IT>
T CircularBuffer<T,S,IT>::shift() {
	if (count == 0) return *head;
	T result = *head++;
6000262a:	6833      	ldr	r3, [r6, #0]
	   '7', '8', '9', '0', '0', '0','0', '0', };
uint32_t charIndex = 0;
char currentCharacter = 0;
String renamedPatch = "";

struct PatchNoAndName{
6000262c:	a806      	add	r0, sp, #24
6000262e:	4619      	mov	r1, r3
60002630:	3314      	adds	r3, #20
60002632:	f851 2b04 	ldr.w	r2, [r1], #4
60002636:	6033      	str	r3, [r6, #0]
60002638:	9205      	str	r2, [sp, #20]
6000263a:	f024 fa4d 	bl	60026ad8 <___ZN6StringC1ERKS__veneer>
	if (head >= buffer + capacity) {
6000263e:	6833      	ldr	r3, [r6, #0]
60002640:	a906      	add	r1, sp, #24
60002642:	9a05      	ldr	r2, [sp, #20]
60002644:	a801      	add	r0, sp, #4
60002646:	42b3      	cmp	r3, r6
		head = buffer;
	}
	count--;
60002648:	8823      	ldrh	r3, [r4, #0]
6000264a:	9200      	str	r2, [sp, #0]
6000264c:	f103 33ff 	add.w	r3, r3, #4294967295
template<typename T, size_t S, typename IT>
T CircularBuffer<T,S,IT>::shift() {
	if (count == 0) return *head;
	T result = *head++;
	if (head >= buffer + capacity) {
		head = buffer;
60002650:	bf28      	it	cs
60002652:	f8c6 9000 	strcs.w	r9, [r6]
	}
	count--;
60002656:	8023      	strh	r3, [r4, #0]
60002658:	f024 fa92 	bl	60026b80 <___ZN6StringC1EOS__veneer>
6000265c:	a806      	add	r0, sp, #24
6000265e:	f024 f97f 	bl	60026960 <___ZN6StringD1Ev_veneer>
	}
}

template<typename T, size_t S, typename IT>
bool CircularBuffer<T,S,IT>::push(T value) {
	if (++tail == buffer + capacity) {
60002662:	6838      	ldr	r0, [r7, #0]
60002664:	3014      	adds	r0, #20
60002666:	42a8      	cmp	r0, r5
60002668:	6038      	str	r0, [r7, #0]
6000266a:	d02e      	beq.n	600026ca <setPatchesOrdering(int) [clone .part.92]+0xba>
6000266c:	9b00      	ldr	r3, [sp, #0]
6000266e:	a901      	add	r1, sp, #4
60002670:	f840 3b04 	str.w	r3, [r0], #4
60002674:	f024 fa68 	bl	60026b48 <___ZN6StringaSERKS__veneer>
		tail = buffer;
	}
	*tail = value;
	if (count == capacity) {
60002678:	8823      	ldrh	r3, [r4, #0]
6000267a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
6000267e:	d028      	beq.n	600026d2 <setPatchesOrdering(int) [clone .part.92]+0xc2>
		if (++head == buffer + capacity) {
			head = buffer;
		}
		return false;
	} else {
		if (count++ == 0) {
60002680:	1c5a      	adds	r2, r3, #1
60002682:	8022      	strh	r2, [r4, #0]
60002684:	b90b      	cbnz	r3, 6000268a <setPatchesOrdering(int) [clone .part.92]+0x7a>
			head = tail;
60002686:	683b      	ldr	r3, [r7, #0]
60002688:	602b      	str	r3, [r5, #0]
6000268a:	a801      	add	r0, sp, #4
6000268c:	f024 f968 	bl	60026960 <___ZN6StringD1Ev_veneer>
60002690:	6829      	ldr	r1, [r5, #0]
60002692:	a806      	add	r0, sp, #24
60002694:	f851 3b04 	ldr.w	r3, [r1], #4
60002698:	9305      	str	r3, [sp, #20]
6000269a:	f024 fa1d 	bl	60026ad8 <___ZN6StringC1ERKS__veneer>
  deletePatch(String(patches.size() + 1).c_str()); //Delete final patch which is duplicate of penultimate patch
}

FLASHMEM void setPatchesOrdering(int no) {
  if (patches.size() < 2)return;
  while (patches.first().patchNo != no) {
6000269e:	f8dd b014 	ldr.w	fp, [sp, #20]
	   '7', '8', '9', '0', '0', '0','0', '0', };
uint32_t charIndex = 0;
char currentCharacter = 0;
String renamedPatch = "";

struct PatchNoAndName{
600026a2:	a806      	add	r0, sp, #24
600026a4:	f024 f95c 	bl	60026960 <___ZN6StringD1Ev_veneer>
  deletePatch(String(patches.size() + 1).c_str()); //Delete final patch which is duplicate of penultimate patch
}

FLASHMEM void setPatchesOrdering(int no) {
  if (patches.size() < 2)return;
  while (patches.first().patchNo != no) {
600026a8:	45c3      	cmp	fp, r8
600026aa:	d019      	beq.n	600026e0 <setPatchesOrdering(int) [clone .part.92]+0xd0>
	}
}

template<typename T, size_t S, typename IT>
T CircularBuffer<T,S,IT>::shift() {
	if (count == 0) return *head;
600026ac:	8823      	ldrh	r3, [r4, #0]
600026ae:	2b00      	cmp	r3, #0
600026b0:	d1bb      	bne.n	6000262a <setPatchesOrdering(int) [clone .part.92]+0x1a>
	   '7', '8', '9', '0', '0', '0','0', '0', };
uint32_t charIndex = 0;
char currentCharacter = 0;
String renamedPatch = "";

struct PatchNoAndName{
600026b2:	6831      	ldr	r1, [r6, #0]
600026b4:	a801      	add	r0, sp, #4
600026b6:	f851 3b04 	ldr.w	r3, [r1], #4
600026ba:	9300      	str	r3, [sp, #0]
600026bc:	f024 fa0c 	bl	60026ad8 <___ZN6StringC1ERKS__veneer>
	}
}

template<typename T, size_t S, typename IT>
bool CircularBuffer<T,S,IT>::push(T value) {
	if (++tail == buffer + capacity) {
600026c0:	6838      	ldr	r0, [r7, #0]
600026c2:	3014      	adds	r0, #20
600026c4:	42a8      	cmp	r0, r5
600026c6:	6038      	str	r0, [r7, #0]
600026c8:	d1d0      	bne.n	6000266c <setPatchesOrdering(int) [clone .part.92]+0x5c>
		tail = buffer;
600026ca:	4808      	ldr	r0, [pc, #32]	; (600026ec <setPatchesOrdering(int) [clone .part.92]+0xdc>)
600026cc:	f8ca 9000 	str.w	r9, [sl]
600026d0:	e7cc      	b.n	6000266c <setPatchesOrdering(int) [clone .part.92]+0x5c>
	}
	*tail = value;
	if (count == capacity) {
		if (++head == buffer + capacity) {
600026d2:	682b      	ldr	r3, [r5, #0]
600026d4:	3314      	adds	r3, #20
			head = buffer;
600026d6:	42ab      	cmp	r3, r5
600026d8:	bf08      	it	eq
600026da:	464b      	moveq	r3, r9
600026dc:	602b      	str	r3, [r5, #0]
600026de:	e7d4      	b.n	6000268a <setPatchesOrdering(int) [clone .part.92]+0x7a>
FLASHMEM void setPatchesOrdering(int no) {
  if (patches.size() < 2)return;
  while (patches.first().patchNo != no) {
    patches.push(patches.shift());
  }
}
600026e0:	b00b      	add	sp, #44	; 0x2c
600026e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
600026e6:	bf00      	nop
600026e8:	2000f2c0 	.word	0x2000f2c0
600026ec:	2000a2c0 	.word	0x2000a2c0

600026f0 <recallPatternData(File, String*) [clone .constprop.154]>:
}

//**************************************************************
// Load/Save Sequencer Pattern
//**************************************************************
FLASHMEM void recallPatternData(File patchFile, String data[]){
600026f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
600026f4:	4606      	mov	r6, r0
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
600026f6:	6900      	ldr	r0, [r0, #16]
600026f8:	b08a      	sub	sp, #40	; 0x28
600026fa:	2800      	cmp	r0, #0
600026fc:	d068      	beq.n	600027d0 <recallPatternData(File, String*) [clone .constprop.154]+0xe0>
600026fe:	460f      	mov	r7, r1
60002700:	f04f 0800 	mov.w	r8, #0
60002704:	e030      	b.n	60002768 <recallPatternData(File, String*) [clone .constprop.154]+0x78>
    if (strchr(delim, ch))
    {
      break;
    }
  }
  str[n] = '\0';
60002706:	ab0a      	add	r3, sp, #40	; 0x28
60002708:	2200      	movs	r2, #0
6000270a:	4423      	add	r3, r4
6000270c:	f803 2c14 	strb.w	r2, [r3, #-20]
  int i = 0;
  while (patchFile.available() && i < NO_OF_SEQ_PARAMS)
  {
    n = readField(&patchFile, str, sizeof(str), ",\n");
    // done if Error or at EOF.
    if (n == 0)
60002710:	2c00      	cmp	r4, #0
60002712:	d05d      	beq.n	600027d0 <recallPatternData(File, String*) [clone .constprop.154]+0xe0>
60002714:	ad01      	add	r5, sp, #4
      break;
    // Print the type of delimiter.
    if (str[n - 1] == ',' || str[n - 1] == '\n')
60002716:	ab0a      	add	r3, sp, #40	; 0x28
60002718:	3c01      	subs	r4, #1
6000271a:	441c      	add	r4, r3
6000271c:	f814 3c14 	ldrb.w	r3, [r4, #-20]
60002720:	2b2c      	cmp	r3, #44	; 0x2c
60002722:	d04f      	beq.n	600027c4 <recallPatternData(File, String*) [clone .constprop.154]+0xd4>
60002724:	2b0a      	cmp	r3, #10
60002726:	d04d      	beq.n	600027c4 <recallPatternData(File, String*) [clone .constprop.154]+0xd4>
60002728:	6930      	ldr	r0, [r6, #16]
6000272a:	2800      	cmp	r0, #0
6000272c:	d04e      	beq.n	600027cc <recallPatternData(File, String*) [clone .constprop.154]+0xdc>
6000272e:	6803      	ldr	r3, [r0, #0]
60002730:	691b      	ldr	r3, [r3, #16]
60002732:	4798      	blx	r3
      str[n - 1] = 0;
    }
    else
    {
      // At eof, too long, or read error.  Too long is error.
      Serial.print(patchFile.available() ? F("error: ") : F("eof:   "));
60002734:	2800      	cmp	r0, #0
60002736:	d049      	beq.n	600027cc <recallPatternData(File, String*) [clone .constprop.154]+0xdc>
60002738:	4827      	ldr	r0, [pc, #156]	; (600027d8 <recallPatternData(File, String*) [clone .constprop.154]+0xe8>)
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
6000273a:	2107      	movs	r1, #7
6000273c:	f024 f938 	bl	600269b0 <__usb_serial_write_veneer>
	  SDErrorFlag = 1;
60002740:	4b26      	ldr	r3, [pc, #152]	; (600027dc <recallPatternData(File, String*) [clone .constprop.154]+0xec>)
60002742:	2201      	movs	r2, #1
60002744:	701a      	strb	r2, [r3, #0]
    }
    data[i++] = String(str);
60002746:	a905      	add	r1, sp, #20
60002748:	4628      	mov	r0, r5
6000274a:	f024 f925 	bl	60026998 <___ZN6StringC1EPKc_veneer>
6000274e:	4629      	mov	r1, r5
60002750:	4638      	mov	r0, r7
60002752:	f108 0801 	add.w	r8, r8, #1
60002756:	f024 f9a3 	bl	60026aa0 <___ZN6StringaSEOS__veneer>
6000275a:	4628      	mov	r0, r5
6000275c:	f024 f900 	bl	60026960 <___ZN6StringD1Ev_veneer>
60002760:	6930      	ldr	r0, [r6, #16]
60002762:	3710      	adds	r7, #16
60002764:	2800      	cmp	r0, #0
60002766:	d033      	beq.n	600027d0 <recallPatternData(File, String*) [clone .constprop.154]+0xe0>
60002768:	6803      	ldr	r3, [r0, #0]
6000276a:	691b      	ldr	r3, [r3, #16]
6000276c:	4798      	blx	r3
	
  //Read patch data from file and set current patch parameters
  size_t n;     // Length of returned field with delimiter.
  char str[20]; // Must hold longest field with delimiter and zero byte.
  int i = 0;
  while (patchFile.available() && i < NO_OF_SEQ_PARAMS)
6000276e:	b378      	cbz	r0, 600027d0 <recallPatternData(File, String*) [clone .constprop.154]+0xe0>
60002770:	f1b8 0f75 	cmp.w	r8, #117	; 0x75
60002774:	dc2c      	bgt.n	600027d0 <recallPatternData(File, String*) [clone .constprop.154]+0xe0>
60002776:	2400      	movs	r4, #0
60002778:	f10d 0914 	add.w	r9, sp, #20
6000277c:	f104 0a01 	add.w	sl, r4, #1
60002780:	f1ba 0f14 	cmp.w	sl, #20
60002784:	d0bf      	beq.n	60002706 <recallPatternData(File, String*) [clone .constprop.154]+0x16>
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
60002786:	a901      	add	r1, sp, #4
60002788:	6933      	ldr	r3, [r6, #16]
6000278a:	2201      	movs	r2, #1
6000278c:	460d      	mov	r5, r1
6000278e:	4618      	mov	r0, r3
60002790:	2b00      	cmp	r3, #0
60002792:	d0b8      	beq.n	60002706 <recallPatternData(File, String*) [clone .constprop.154]+0x16>
60002794:	681b      	ldr	r3, [r3, #0]
60002796:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60002798:	4798      	blx	r3
CircularBuffer<PatchNoAndName, PATCHES_LIMIT> patches;

FLASHMEM size_t readField(File *file, char *str, size_t size, const char *delim){
  char ch;
  size_t n = 0;
  while ((n + 1) < size && file->read(&ch, 1) == 1)
6000279a:	2801      	cmp	r0, #1
6000279c:	d1b3      	bne.n	60002706 <recallPatternData(File, String*) [clone .constprop.154]+0x16>
  {
    // Delete CR.
    if (ch == '\r')
6000279e:	f89d 3004 	ldrb.w	r3, [sp, #4]
600027a2:	2b0d      	cmp	r3, #13
600027a4:	d0ef      	beq.n	60002786 <recallPatternData(File, String*) [clone .constprop.154]+0x96>
    {
      continue;
    }
    str[n++] = ch;
    if (strchr(delim, ch))
600027a6:	4619      	mov	r1, r3
600027a8:	480d      	ldr	r0, [pc, #52]	; (600027e0 <recallPatternData(File, String*) [clone .constprop.154]+0xf0>)
    // Delete CR.
    if (ch == '\r')
    {
      continue;
    }
    str[n++] = ch;
600027aa:	f809 3b01 	strb.w	r3, [r9], #1
600027ae:	4654      	mov	r4, sl
    if (strchr(delim, ch))
600027b0:	f024 f8f6 	bl	600269a0 <__strchr_veneer>
600027b4:	2800      	cmp	r0, #0
600027b6:	d0e1      	beq.n	6000277c <recallPatternData(File, String*) [clone .constprop.154]+0x8c>
    {
      break;
    }
  }
  str[n] = '\0';
600027b8:	ab0a      	add	r3, sp, #40	; 0x28
600027ba:	2200      	movs	r2, #0
600027bc:	4453      	add	r3, sl
600027be:	f803 2c14 	strb.w	r2, [r3, #-20]
600027c2:	e7a8      	b.n	60002716 <recallPatternData(File, String*) [clone .constprop.154]+0x26>
      break;
    // Print the type of delimiter.
    if (str[n - 1] == ',' || str[n - 1] == '\n')
    {
      // Remove the delimiter.
      str[n - 1] = 0;
600027c4:	2300      	movs	r3, #0
600027c6:	f804 3c14 	strb.w	r3, [r4, #-20]
600027ca:	e7bc      	b.n	60002746 <recallPatternData(File, String*) [clone .constprop.154]+0x56>
    }
    else
    {
      // At eof, too long, or read error.  Too long is error.
      Serial.print(patchFile.available() ? F("error: ") : F("eof:   "));
600027cc:	4805      	ldr	r0, [pc, #20]	; (600027e4 <recallPatternData(File, String*) [clone .constprop.154]+0xf4>)
600027ce:	e7b4      	b.n	6000273a <recallPatternData(File, String*) [clone .constprop.154]+0x4a>
	  SDErrorFlag = 1;
    }
    data[i++] = String(str);
  }
}
600027d0:	b00a      	add	sp, #40	; 0x28
600027d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
600027d6:	bf00      	nop
600027d8:	200005c4 	.word	0x200005c4
600027dc:	20013460 	.word	0x20013460
600027e0:	200005d4 	.word	0x200005d4
600027e4:	200005cc 	.word	0x200005cc

600027e8 <recallPatchData(File, String*) [clone .constprop.141]>:
  }
  str[n] = '\0';
  return n;
}

FLASHMEM void recallPatchData(File patchFile, String data[]){
600027e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
600027ec:	4606      	mov	r6, r0
	}
	virtual size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	virtual int available() {
		return (f) ? f->available() : 0;
600027ee:	6900      	ldr	r0, [r0, #16]
600027f0:	b08a      	sub	sp, #40	; 0x28
600027f2:	2800      	cmp	r0, #0
600027f4:	d068      	beq.n	600028c8 <recallPatchData(File, String*) [clone .constprop.141]+0xe0>
600027f6:	460f      	mov	r7, r1
600027f8:	f04f 0800 	mov.w	r8, #0
600027fc:	e030      	b.n	60002860 <recallPatchData(File, String*) [clone .constprop.141]+0x78>
    if (strchr(delim, ch))
    {
      break;
    }
  }
  str[n] = '\0';
600027fe:	ab0a      	add	r3, sp, #40	; 0x28
60002800:	2200      	movs	r2, #0
60002802:	4423      	add	r3, r4
60002804:	f803 2c14 	strb.w	r2, [r3, #-20]
  int i = 0;
  while (patchFile.available() && i < NO_OF_PARAMS)
  {
    n = readField(&patchFile, str, sizeof(str), ",\n");
    // done if Error or at EOF.
    if (n == 0)
60002808:	2c00      	cmp	r4, #0
6000280a:	d05d      	beq.n	600028c8 <recallPatchData(File, String*) [clone .constprop.141]+0xe0>
6000280c:	ad01      	add	r5, sp, #4
      break;
    // Print the type of delimiter.
    if (str[n - 1] == ',' || str[n - 1] == '\n')
6000280e:	ab0a      	add	r3, sp, #40	; 0x28
60002810:	3c01      	subs	r4, #1
60002812:	441c      	add	r4, r3
60002814:	f814 3c14 	ldrb.w	r3, [r4, #-20]
60002818:	2b2c      	cmp	r3, #44	; 0x2c
6000281a:	d04f      	beq.n	600028bc <recallPatchData(File, String*) [clone .constprop.141]+0xd4>
6000281c:	2b0a      	cmp	r3, #10
6000281e:	d04d      	beq.n	600028bc <recallPatchData(File, String*) [clone .constprop.141]+0xd4>
60002820:	6930      	ldr	r0, [r6, #16]
60002822:	2800      	cmp	r0, #0
60002824:	d04e      	beq.n	600028c4 <recallPatchData(File, String*) [clone .constprop.141]+0xdc>
60002826:	6803      	ldr	r3, [r0, #0]
60002828:	691b      	ldr	r3, [r3, #16]
6000282a:	4798      	blx	r3
      str[n - 1] = 0;
    }
    else
    {
      // At eof, too long, or read error.  Too long is error.
      Serial.print(patchFile.available() ? F("error: ") : F("eof:   "));
6000282c:	2800      	cmp	r0, #0
6000282e:	d049      	beq.n	600028c4 <recallPatchData(File, String*) [clone .constprop.141]+0xdc>
60002830:	4827      	ldr	r0, [pc, #156]	; (600028d0 <recallPatchData(File, String*) [clone .constprop.141]+0xe8>)
60002832:	2107      	movs	r1, #7
60002834:	f024 f8bc 	bl	600269b0 <__usb_serial_write_veneer>
	  SDErrorFlag = 1;
60002838:	4b26      	ldr	r3, [pc, #152]	; (600028d4 <recallPatchData(File, String*) [clone .constprop.141]+0xec>)
6000283a:	2201      	movs	r2, #1
6000283c:	701a      	strb	r2, [r3, #0]
       Serial.print(i);
       Serial.print(" - ");
       Serial.println(str);
	   */
	   
    data[i++] = String(str);
6000283e:	a905      	add	r1, sp, #20
60002840:	4628      	mov	r0, r5
60002842:	f024 f8a9 	bl	60026998 <___ZN6StringC1EPKc_veneer>
60002846:	4629      	mov	r1, r5
60002848:	4638      	mov	r0, r7
6000284a:	f108 0801 	add.w	r8, r8, #1
6000284e:	f024 f927 	bl	60026aa0 <___ZN6StringaSEOS__veneer>
60002852:	4628      	mov	r0, r5
60002854:	f024 f884 	bl	60026960 <___ZN6StringD1Ev_veneer>
60002858:	6930      	ldr	r0, [r6, #16]
6000285a:	3710      	adds	r7, #16
6000285c:	2800      	cmp	r0, #0
6000285e:	d033      	beq.n	600028c8 <recallPatchData(File, String*) [clone .constprop.141]+0xe0>
60002860:	6803      	ldr	r3, [r0, #0]
60002862:	691b      	ldr	r3, [r3, #16]
60002864:	4798      	blx	r3
FLASHMEM void recallPatchData(File patchFile, String data[]){
  //Read patch data from file and set current patch parameters
  size_t n;     // Length of returned field with delimiter.
  char str[20]; // Must hold longest field with delimiter and zero byte.
  int i = 0;
  while (patchFile.available() && i < NO_OF_PARAMS)
60002866:	b378      	cbz	r0, 600028c8 <recallPatchData(File, String*) [clone .constprop.141]+0xe0>
60002868:	f1b8 0fbf 	cmp.w	r8, #191	; 0xbf
6000286c:	dc2c      	bgt.n	600028c8 <recallPatchData(File, String*) [clone .constprop.141]+0xe0>
6000286e:	2400      	movs	r4, #0
60002870:	f10d 0914 	add.w	r9, sp, #20
60002874:	f104 0a01 	add.w	sl, r4, #1
60002878:	f1ba 0f14 	cmp.w	sl, #20
6000287c:	d0bf      	beq.n	600027fe <recallPatchData(File, String*) [clone .constprop.141]+0x16>
	unsigned int getRefcount() { // testing only
		return refcount;
	}
#endif
	virtual size_t read(void *buf, size_t nbyte) {
		return (f) ? f->read(buf, nbyte) : 0;
6000287e:	a901      	add	r1, sp, #4
60002880:	6933      	ldr	r3, [r6, #16]
60002882:	2201      	movs	r2, #1
60002884:	460d      	mov	r5, r1
60002886:	4618      	mov	r0, r3
60002888:	2b00      	cmp	r3, #0
6000288a:	d0b8      	beq.n	600027fe <recallPatchData(File, String*) [clone .constprop.141]+0x16>
6000288c:	681b      	ldr	r3, [r3, #0]
6000288e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
60002890:	4798      	blx	r3
CircularBuffer<PatchNoAndName, PATCHES_LIMIT> patches;

FLASHMEM size_t readField(File *file, char *str, size_t size, const char *delim){
  char ch;
  size_t n = 0;
  while ((n + 1) < size && file->read(&ch, 1) == 1)
60002892:	2801      	cmp	r0, #1
60002894:	d1b3      	bne.n	600027fe <recallPatchData(File, String*) [clone .constprop.141]+0x16>
  {
    // Delete CR.
    if (ch == '\r')
60002896:	f89d 3004 	ldrb.w	r3, [sp, #4]
6000289a:	2b0d      	cmp	r3, #13
6000289c:	d0ef      	beq.n	6000287e <recallPatchData(File, String*) [clone .constprop.141]+0x96>
    {
      continue;
    }
    str[n++] = ch;
    if (strchr(delim, ch))
6000289e:	4619      	mov	r1, r3
600028a0:	480d      	ldr	r0, [pc, #52]	; (600028d8 <recallPatchData(File, String*) [clone .constprop.141]+0xf0>)
    // Delete CR.
    if (ch == '\r')
    {
      continue;
    }
    str[n++] = ch;
600028a2:	f809 3b01 	strb.w	r3, [r9], #1
600028a6:	4654      	mov	r4, sl
    if (strchr(delim, ch))
600028a8:	f024 f87a 	bl	600269a0 <__strchr_veneer>
600028ac:	2800      	cmp	r0, #0
600028ae:	d0e1      	beq.n	60002874 <recallPatchData(File, String*) [clone .constprop.141]+0x8c>
    {
      break;
    }
  }
  str[n] = '\0';
600028b0:	ab0a      	add	r3, sp, #40	; 0x28
600028b2:	2200      	movs	r2, #0
600028b4:	4453      	add	r3, sl
600028b6:	f803 2c14 	strb.w	r2, [r3, #-20]
600028ba:	e7a8      	b.n	6000280e <recallPatchData(File, String*) [clone .constprop.141]+0x26>
      break;
    // Print the type of delimiter.
    if (str[n - 1] == ',' || str[n - 1] == '\n')
    {
      // Remove the delimiter.
      str[n - 1] = 0;
600028bc:	2300      	movs	r3, #0
600028be:	f804 3c14 	strb.w	r3, [r4, #-20]
600028c2:	e7bc      	b.n	6000283e <recallPatchData(File, String*) [clone .constprop.141]+0x56>
    }
    else
    {
      // At eof, too long, or read error.  Too long is error.
      Serial.print(patchFile.available() ? F("error: ") : F("eof:   "));
600028c4:	4805      	ldr	r0, [pc, #20]	; (600028dc <recallPatchData(File, String*) [clone .constprop.141]+0xf4>)
600028c6:	e7b4      	b.n	60002832 <recallPatchData(File, String*) [clone .constprop.141]+0x4a>
       Serial.println(str);
	   */
	   
    data[i++] = String(str);
  }
}
600028c8:	b00a      	add	sp, #40	; 0x28
600028ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
600028ce:	bf00      	nop
600028d0:	200005c4 	.word	0x200005c4
600028d4:	20013460 	.word	0x20013460
600028d8:	200005d4 	.word	0x200005d4
600028dc:	200005cc 	.word	0x200005cc

600028e0 <setLED(unsigned char, bool) [clone .constprop.183]>:
	}
	temp_read = encRead;	
		
	if (Keylock == true) { // if Load/Save function than encoder funktion disabled
		return;
	}
600028e0:	4a1d      	ldr	r2, [pc, #116]	; (60002958 <setLED(unsigned char, bool) [clone .constprop.183]+0x78>)
FLASHMEM void checkEncoder(void)
{
	
	static long temp_read = 0;
	long encRead = encoder.read();
	if (encRead == temp_read) {
600028e2:	b510      	push	{r4, lr}
	}
	temp_read = encRead;	
		
	if (Keylock == true) { // if Load/Save function than encoder funktion disabled
		return;
	}
600028e4:	7813      	ldrb	r3, [r2, #0]
		return;
	}
	temp_read = encRead;	
		
	if (Keylock == true) { // if Load/Save function than encoder funktion disabled
		return;
600028e6:	2800      	cmp	r0, #0
600028e8:	d033      	beq.n	60002952 <setLED(unsigned char, bool) [clone .constprop.183]+0x72>
	}
600028ea:	f043 0301 	orr.w	r3, r3, #1
600028ee:	4c1b      	ldr	r4, [pc, #108]	; (6000295c <setLED(unsigned char, bool) [clone .constprop.183]+0x7c>)
600028f0:	7013      	strb	r3, [r2, #0]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
600028f2:	6822      	ldr	r2, [r4, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
600028f4:	6653      	str	r3, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
600028f6:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
600028f8:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
600028fc:	d0fb      	beq.n	600028f6 <setLED(unsigned char, bool) [clone .constprop.183]+0x16>
			}
			encPrevious = encRead;
		}
	}
	// selected PatchNo --------------------------------------------------
	else {
600028fe:	2100      	movs	r1, #0
60002900:	2024      	movs	r0, #36	; 0x24
60002902:	6f53      	ldr	r3, [r2, #116]	; 0x74
60002904:	f023 ff84 	bl	60026810 <__digitalWrite_veneer>
		uint8_t oldpatchNo = patchNo;
60002908:	2101      	movs	r1, #1
6000290a:	2024      	movs	r0, #36	; 0x24
6000290c:	f023 ff80 	bl	60026810 <__digitalWrite_veneer>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
60002910:	7ce3      	ldrb	r3, [r4, #19]
60002912:	4912      	ldr	r1, [pc, #72]	; (6000295c <setLED(unsigned char, bool) [clone .constprop.183]+0x7c>)
60002914:	461a      	mov	r2, r3
60002916:	b1db      	cbz	r3, 60002950 <setLED(unsigned char, bool) [clone .constprop.183]+0x70>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
60002918:	07d8      	lsls	r0, r3, #31
6000291a:	d502      	bpl.n	60002922 <setLED(unsigned char, bool) [clone .constprop.183]+0x42>
6000291c:	6a88      	ldr	r0, [r1, #40]	; 0x28
6000291e:	4910      	ldr	r1, [pc, #64]	; (60002960 <setLED(unsigned char, bool) [clone .constprop.183]+0x80>)
60002920:	6008      	str	r0, [r1, #0]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
60002922:	079b      	lsls	r3, r3, #30
60002924:	d503      	bpl.n	6000292e <setLED(unsigned char, bool) [clone .constprop.183]+0x4e>
60002926:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
60002928:	4b0e      	ldr	r3, [pc, #56]	; (60002964 <setLED(unsigned char, bool) [clone .constprop.183]+0x84>)
6000292a:	7ce2      	ldrb	r2, [r4, #19]
6000292c:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
6000292e:	0750      	lsls	r0, r2, #29
60002930:	d503      	bpl.n	6000293a <setLED(unsigned char, bool) [clone .constprop.183]+0x5a>
60002932:	6b21      	ldr	r1, [r4, #48]	; 0x30
60002934:	4b0c      	ldr	r3, [pc, #48]	; (60002968 <setLED(unsigned char, bool) [clone .constprop.183]+0x88>)
60002936:	7ce2      	ldrb	r2, [r4, #19]
60002938:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
6000293a:	0711      	lsls	r1, r2, #28
6000293c:	d503      	bpl.n	60002946 <setLED(unsigned char, bool) [clone .constprop.183]+0x66>
6000293e:	6b61      	ldr	r1, [r4, #52]	; 0x34
60002940:	4b0a      	ldr	r3, [pc, #40]	; (6000296c <setLED(unsigned char, bool) [clone .constprop.183]+0x8c>)
60002942:	7ce2      	ldrb	r2, [r4, #19]
60002944:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
60002946:	06d3      	lsls	r3, r2, #27
60002948:	d502      	bpl.n	60002950 <setLED(unsigned char, bool) [clone .constprop.183]+0x70>
6000294a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
6000294c:	4b08      	ldr	r3, [pc, #32]	; (60002970 <setLED(unsigned char, bool) [clone .constprop.183]+0x90>)
6000294e:	601a      	str	r2, [r3, #0]
60002950:	bd10      	pop	{r4, pc}
	if (Keylock == true) { // if Load/Save function than encoder funktion disabled
		return;
	}
	
	// selected Parameter Pages -----------------------------------------
	if (PageNr > 0) {
60002952:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
60002956:	e7ca      	b.n	600028ee <setLED(unsigned char, bool) [clone .constprop.183]+0xe>
60002958:	20007e2d 	.word	0x20007e2d
6000295c:	20004ecc 	.word	0x20004ecc
60002960:	e000e100 	.word	0xe000e100
60002964:	e000e104 	.word	0xe000e104
60002968:	e000e108 	.word	0xe000e108
6000296c:	e000e10c 	.word	0xe000e10c
60002970:	e000e110 	.word	0xe000e110

60002974 <setLED(unsigned char, bool) [clone .constprop.184]>:
				PageNr = Pages;
			}
			else if (PageNr < 1){
				PageNr = 1;
			}
			if (oldPageNr != PageNr) {
60002974:	4a1d      	ldr	r2, [pc, #116]	; (600029ec <setLED(unsigned char, bool) [clone .constprop.184]+0x78>)
FLASHMEM void checkEncoder(void)
{
	
	static long temp_read = 0;
	long encRead = encoder.read();
	if (encRead == temp_read) {
60002976:	b510      	push	{r4, lr}
				PageNr = Pages;
			}
			else if (PageNr < 1){
				PageNr = 1;
			}
			if (oldPageNr != PageNr) {
60002978:	7813      	ldrb	r3, [r2, #0]
			if (PageNr > Pages){
				PageNr = Pages;
			}
			else if (PageNr < 1){
				PageNr = 1;
			}
6000297a:	2800      	cmp	r0, #0
6000297c:	d033      	beq.n	600029e6 <setLED(unsigned char, bool) [clone .constprop.184]+0x72>
			if (oldPageNr != PageNr) {
6000297e:	f043 0308 	orr.w	r3, r3, #8
60002982:	4c1b      	ldr	r4, [pc, #108]	; (600029f0 <setLED(unsigned char, bool) [clone .constprop.184]+0x7c>)
60002984:	7013      	strb	r3, [r2, #0]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
60002986:	6822      	ldr	r2, [r4, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
60002988:	6653      	str	r3, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
6000298a:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
6000298c:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
60002990:	d0fb      	beq.n	6000298a <setLED(unsigned char, bool) [clone .constprop.184]+0x16>
			}
			encPrevious = encRead;
		}
	}
	// selected PatchNo --------------------------------------------------
	else {
60002992:	2100      	movs	r1, #0
60002994:	2024      	movs	r0, #36	; 0x24
60002996:	6f53      	ldr	r3, [r2, #116]	; 0x74
60002998:	f023 ff3a 	bl	60026810 <__digitalWrite_veneer>
		uint8_t oldpatchNo = patchNo;
6000299c:	2101      	movs	r1, #1
6000299e:	2024      	movs	r0, #36	; 0x24
600029a0:	f023 ff36 	bl	60026810 <__digitalWrite_veneer>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
600029a4:	7ce3      	ldrb	r3, [r4, #19]
600029a6:	4912      	ldr	r1, [pc, #72]	; (600029f0 <setLED(unsigned char, bool) [clone .constprop.184]+0x7c>)
600029a8:	461a      	mov	r2, r3
600029aa:	b1db      	cbz	r3, 600029e4 <setLED(unsigned char, bool) [clone .constprop.184]+0x70>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
600029ac:	07d8      	lsls	r0, r3, #31
600029ae:	d502      	bpl.n	600029b6 <setLED(unsigned char, bool) [clone .constprop.184]+0x42>
600029b0:	6a88      	ldr	r0, [r1, #40]	; 0x28
600029b2:	4910      	ldr	r1, [pc, #64]	; (600029f4 <setLED(unsigned char, bool) [clone .constprop.184]+0x80>)
600029b4:	6008      	str	r0, [r1, #0]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
600029b6:	079b      	lsls	r3, r3, #30
600029b8:	d503      	bpl.n	600029c2 <setLED(unsigned char, bool) [clone .constprop.184]+0x4e>
600029ba:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
600029bc:	4b0e      	ldr	r3, [pc, #56]	; (600029f8 <setLED(unsigned char, bool) [clone .constprop.184]+0x84>)
600029be:	7ce2      	ldrb	r2, [r4, #19]
600029c0:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
600029c2:	0750      	lsls	r0, r2, #29
600029c4:	d503      	bpl.n	600029ce <setLED(unsigned char, bool) [clone .constprop.184]+0x5a>
600029c6:	6b21      	ldr	r1, [r4, #48]	; 0x30
600029c8:	4b0c      	ldr	r3, [pc, #48]	; (600029fc <setLED(unsigned char, bool) [clone .constprop.184]+0x88>)
600029ca:	7ce2      	ldrb	r2, [r4, #19]
600029cc:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
600029ce:	0711      	lsls	r1, r2, #28
600029d0:	d503      	bpl.n	600029da <setLED(unsigned char, bool) [clone .constprop.184]+0x66>
600029d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
600029d4:	4b0a      	ldr	r3, [pc, #40]	; (60002a00 <setLED(unsigned char, bool) [clone .constprop.184]+0x8c>)
600029d6:	7ce2      	ldrb	r2, [r4, #19]
600029d8:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
600029da:	06d3      	lsls	r3, r2, #27
600029dc:	d502      	bpl.n	600029e4 <setLED(unsigned char, bool) [clone .constprop.184]+0x70>
600029de:	6ba2      	ldr	r2, [r4, #56]	; 0x38
600029e0:	4b08      	ldr	r3, [pc, #32]	; (60002a04 <setLED(unsigned char, bool) [clone .constprop.184]+0x90>)
600029e2:	601a      	str	r2, [r3, #0]
600029e4:	bd10      	pop	{r4, pc}
				PageNr = 1;
			}
			if (oldPageNr != PageNr) {
				renderCurrentPatchPage();
			}
			encPrevious = encRead;
600029e6:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
600029ea:	e7ca      	b.n	60002982 <setLED(unsigned char, bool) [clone .constprop.184]+0xe>
600029ec:	20007e2d 	.word	0x20007e2d
600029f0:	20004ecc 	.word	0x20004ecc
600029f4:	e000e100 	.word	0xe000e100
600029f8:	e000e104 	.word	0xe000e104
600029fc:	e000e108 	.word	0xe000e108
60002a00:	e000e10c 	.word	0xe000e10c
60002a04:	e000e110 	.word	0xe000e110

60002a08 <setLED(unsigned char, bool) [clone .constprop.185]>:
		uint8_t oldPageNr = PageNr;
		if ((encCW && encRead > encPrevious + 3) || (!encCW && encRead < encPrevious - 3)) {
			PageNr++;
			if (PageNr > Pages){
				PageNr = Pages;
			}
60002a08:	4a1d      	ldr	r2, [pc, #116]	; (60002a80 <setLED(unsigned char, bool) [clone .constprop.185]+0x78>)
FLASHMEM void checkEncoder(void)
{
	
	static long temp_read = 0;
	long encRead = encoder.read();
	if (encRead == temp_read) {
60002a0a:	b510      	push	{r4, lr}
		uint8_t oldPageNr = PageNr;
		if ((encCW && encRead > encPrevious + 3) || (!encCW && encRead < encPrevious - 3)) {
			PageNr++;
			if (PageNr > Pages){
				PageNr = Pages;
			}
60002a0c:	7813      	ldrb	r3, [r2, #0]
		//long encRead = encoder.read();
		uint8_t oldPageNr = PageNr;
		if ((encCW && encRead > encPrevious + 3) || (!encCW && encRead < encPrevious - 3)) {
			PageNr++;
			if (PageNr > Pages){
				PageNr = Pages;
60002a0e:	2800      	cmp	r0, #0
60002a10:	d033      	beq.n	60002a7a <setLED(unsigned char, bool) [clone .constprop.185]+0x72>
			}
60002a12:	f043 0302 	orr.w	r3, r3, #2
60002a16:	4c1b      	ldr	r4, [pc, #108]	; (60002a84 <setLED(unsigned char, bool) [clone .constprop.185]+0x7c>)
60002a18:	7013      	strb	r3, [r2, #0]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
60002a1a:	6822      	ldr	r2, [r4, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
60002a1c:	6653      	str	r3, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
60002a1e:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
60002a20:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
60002a24:	d0fb      	beq.n	60002a1e <setLED(unsigned char, bool) [clone .constprop.185]+0x16>
			}
			encPrevious = encRead;
		}
	}
	// selected PatchNo --------------------------------------------------
	else {
60002a26:	2100      	movs	r1, #0
60002a28:	2024      	movs	r0, #36	; 0x24
60002a2a:	6f53      	ldr	r3, [r2, #116]	; 0x74
60002a2c:	f023 fef0 	bl	60026810 <__digitalWrite_veneer>
		uint8_t oldpatchNo = patchNo;
60002a30:	2101      	movs	r1, #1
60002a32:	2024      	movs	r0, #36	; 0x24
60002a34:	f023 feec 	bl	60026810 <__digitalWrite_veneer>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
60002a38:	7ce3      	ldrb	r3, [r4, #19]
60002a3a:	4912      	ldr	r1, [pc, #72]	; (60002a84 <setLED(unsigned char, bool) [clone .constprop.185]+0x7c>)
60002a3c:	461a      	mov	r2, r3
60002a3e:	b1db      	cbz	r3, 60002a78 <setLED(unsigned char, bool) [clone .constprop.185]+0x70>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
60002a40:	07d8      	lsls	r0, r3, #31
60002a42:	d502      	bpl.n	60002a4a <setLED(unsigned char, bool) [clone .constprop.185]+0x42>
60002a44:	6a88      	ldr	r0, [r1, #40]	; 0x28
60002a46:	4910      	ldr	r1, [pc, #64]	; (60002a88 <setLED(unsigned char, bool) [clone .constprop.185]+0x80>)
60002a48:	6008      	str	r0, [r1, #0]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
60002a4a:	079b      	lsls	r3, r3, #30
60002a4c:	d503      	bpl.n	60002a56 <setLED(unsigned char, bool) [clone .constprop.185]+0x4e>
60002a4e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
60002a50:	4b0e      	ldr	r3, [pc, #56]	; (60002a8c <setLED(unsigned char, bool) [clone .constprop.185]+0x84>)
60002a52:	7ce2      	ldrb	r2, [r4, #19]
60002a54:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
60002a56:	0750      	lsls	r0, r2, #29
60002a58:	d503      	bpl.n	60002a62 <setLED(unsigned char, bool) [clone .constprop.185]+0x5a>
60002a5a:	6b21      	ldr	r1, [r4, #48]	; 0x30
60002a5c:	4b0c      	ldr	r3, [pc, #48]	; (60002a90 <setLED(unsigned char, bool) [clone .constprop.185]+0x88>)
60002a5e:	7ce2      	ldrb	r2, [r4, #19]
60002a60:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
60002a62:	0711      	lsls	r1, r2, #28
60002a64:	d503      	bpl.n	60002a6e <setLED(unsigned char, bool) [clone .constprop.185]+0x66>
60002a66:	6b61      	ldr	r1, [r4, #52]	; 0x34
60002a68:	4b0a      	ldr	r3, [pc, #40]	; (60002a94 <setLED(unsigned char, bool) [clone .constprop.185]+0x8c>)
60002a6a:	7ce2      	ldrb	r2, [r4, #19]
60002a6c:	6019      	str	r1, [r3, #0]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
60002a6e:	06d3      	lsls	r3, r2, #27
60002a70:	d502      	bpl.n	60002a78 <setLED(unsigned char, bool) [clone .constprop.185]+0x70>
60002a72:	6ba2      	ldr	r2, [r4, #56]	; 0x38
60002a74:	4b08      	ldr	r3, [pc, #32]	; (60002a98 <setLED(unsigned char, bool) [clone .constprop.185]+0x90>)
60002a76:	601a      	str	r2, [r3, #0]
60002a78:	bd10      	pop	{r4, pc}
			if (PageNr > Pages){
				PageNr = Pages;
			}
			else if (PageNr < 1){
				PageNr = 1;
			}
60002a7a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
60002a7e:	e7ca      	b.n	60002a16 <setLED(unsigned char, bool) [clone .constprop.185]+0xe>
60002a80:	20007e2d 	.word	0x20007e2d
60002a84:	20004ecc 	.word	0x20004ecc
60002a88:	e000e100 	.word	0xe000e100
60002a8c:	e000e104 	.word	0xe000e104
60002a90:	e000e108 	.word	0xe000e108
60002a94:	e000e10c 	.word	0xe000e10c
60002a98:	e000e110 	.word	0xe000e110

60002a9c <myMIDIClock()>:
		updatePitchA();
		updatePitchB();
		updateDetune();
		updatePWMSource();
		updatePWA();
		updatePWB();
60002a9c:	4b4e      	ldr	r3, [pc, #312]	; (60002bd8 <myMIDIClock()+0x13c>)
60002a9e:	781b      	ldrb	r3, [r3, #0]
		updateWaveformB();
		updatePitchA();
		updatePitchB();
		updateDetune();
		updatePWMSource();
		updatePWA();
60002aa0:	b470      	push	{r4, r5, r6}
		updatePWB();
60002aa2:	b153      	cbz	r3, 60002aba <myMIDIClock()+0x1e>
		updatePWMRate();
		updateOscLevelA();
		updateOscLevelB();
60002aa4:	4b4d      	ldr	r3, [pc, #308]	; (60002bdc <myMIDIClock()+0x140>)
60002aa6:	4a4e      	ldr	r2, [pc, #312]	; (60002be0 <myMIDIClock()+0x144>)
60002aa8:	681b      	ldr	r3, [r3, #0]
60002aaa:	2b03      	cmp	r3, #3
60002aac:	d007      	beq.n	60002abe <myMIDIClock()+0x22>
60002aae: